/*globals define*/

/**
 * Generated by AddOnGenerator 1.7.0 from webgme on Tue Jun 18 2019 14:16:36 GMT-0700 (Mountain Standard Time).
 */

define([
    'addon/AddOnBase',
    'q'
], function (AddOnBase,Q) {
    'use strict';

    /**
     * Initializes a new instance of CATVehicleContinuousVerifier.
     * @class
     * @augments {AddOnBase}
     * @classdesc This class represents the addOn CATVehicleContinuousVerifier.
     * @constructor
     */
    var CATVehicleContinuousVerifier = function (mainLogger, gmeConfig) {
        // Call base class' constructor.
        AddOnBase.call(this, mainLogger, gmeConfig);
    };

    // Prototypal inheritance from AddOnBase.
    CATVehicleContinuousVerifier.prototype = Object.create(AddOnBase.prototype);
    CATVehicleContinuousVerifier.prototype.constructor = CATVehicleContinuousVerifier;

    /**
     * Gets the name of the CATVehicleContinuousVerifier.
     * @returns {string} The name of the AddOn.
     * @public
     */
    CATVehicleContinuousVerifier.prototype.getName = function () {
        return 'CATVehicleContinuousVerifier';
    };

    /**
     * Gets the semantic version (semver.org) of the CATVehicleContinuousVerifier.
     * @returns {string} The version of the AddOn.
     * @public
     */
    CATVehicleContinuousVerifier.prototype.getVersion = function () {
        return '0.1.0';
    };
    //Defines control block and builds connection to next node
        CATVehicleContinuousVerifier.prototype.getControlData = async function(abstractControlBlock)
        {
          var self = this,
              deferred = new Q.defer(),
              controlData = {
                  id: self.core.getPath(abstractControlBlock),
                  name: self.core.getAttribute(abstractControlBlock, 'name'),
                  isStart: false,
                  //Code within the loop to execute every iteration
                  CodeToExecute:[],
                  //distance: self.core.getAttribute(PrimitiveMotionNode, 'Distance')
                  Connections: [
                      // event: <string>
                      // targetId: <nodePathStr>
                  ]
              },
              error,
              counter;

              //builds children nodes TODO start with one no connections then work from there
    let curr;
    let promise1;
    let promise2;
    //Builds connections for path for codetoexecute awaits and promises to fix asynchonous
      await new Promise(done=>{ self.core.loadChildren(abstractControlBlock, async function (err, children)
      {
        if(children.length>0)
        {
        if (err) {
           // Something went wrong!
           // Handle the error and return.
           console.log("Error with children");
        }
        // We have an array of the children and can get information from them.
      //get non-connection nodes better for core functions to get next nodes and starting node
      let nonConn = [];
      //loops through all blocks in control blocks and adds all blocks that are not connections
      children.forEach(async (child)=>
      {
        if(!(self.core.isConnection(child)))
        {
          nonConn.push(child);
        }
      })
      //get starting child
      nonConn.forEach(async (child)=>
      {
        console.log(self.core.getAttribute(child,'name'));

          self.core.loadCollection(child, 'dst', function (err, connections) {
          if (err)
          {
            deferred.reject(new Error(err));
            return;
          }
          if(connections.length > 1)
          {
            self.logger.error('Multiple incoming connections: ' + connections.length);
            deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
            return;
          }
          else if(connections.length === 0)
          {
            //If current child is not the dst of any other child it is the start
              curr = child;
              console.log('Found the starting child: ' + self.core.getAttribute(child,'name'));
              //TODO change to type not name push->easy read into matlab
              var name = self.core.getAttribute(child,'name');
              var type;
              //Adds type # not name of block so can be read in Matlab
              if(name ==='Straight')
                type=1;
              else if(name==='Left')
                type = 2;
              else if (name==='Right')
                type = 3;
              else if(name==='ZigZagLeft')
                type = 4;
              else if (name==='ZigZagRight')
                type = 5;
              else if(name==='Horn')
                type = 9;
              else if (name==='Left_Signal')
                type = 10;
              else if(name==='Right_Signal')
                type = 11;
              else if (name==='Hazard')
                type = 12;
              controlData.CodeToExecute.push(type);
              promise1 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("Found Start!"), 1000)
      });
          }
          });
      })
    //Fixes asynch bug where start is not recorded and saved
      await promise1;
      console.log("Async worked? "+self.core.getAttribute(curr,'name'));

      //Loop through src of curr node to add next nodes there is length of nonconnection blocks-1 to loop through
      let k;
      for(k=0;k<nonConn.length-1;k++)
      {
        console.log("Current node: "+self.core.getAttribute(curr,'name'));
        //Fixes asynch bug where every iteration codetoexecute and curr not updated, loops where curr is src of connection
        await new Promise(next=>{
          self.core.loadCollection(curr, 'src', function (err, connections)
        {
            if (err)
            {
                deferred.reject(new Error(err));
                return;
            }
            var i;
            counter = connections.length;
            if(connections.length > 1)
            {
              self.logger.error('Multiple outgoing connections: ' + connections.length);
              deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
              return;
            }
          // For each connection load the destination state.
            for (i = 0; i < connections.length; i += 1)
            {
            self.core.loadPointer(connections[i], 'dst', getNextChild(connections[i]));
            }
            if (connections.length === 0)
            {
              deferred.resolve(controlData);
            }
            //Helps iterate through the list
            next()
        })
      })
      }
      //Debugging statement
    console.log("This is list after: "+controlData.CodeToExecute);
    //Fixes asynch bug where list is not updated to template after path is built
    done();
  }
      });

    });
    //Dummy function to fix asynch bug
    function done()
    {
      console.log("Finished parsing kids hopefully CodeToExecute is updated");
    }



    //Callled to load next dst and set as current then adds type to list
    function getNextChild(connection)
    {
      return function(err, dstNode) {
      if (err) {
      // Handle error
      console.log("Error loading dest");
      }
      // Here we have access to the dstNode.
      curr = dstNode;
      var name = self.core.getAttribute(curr,'name');
      var type;
      if(name ==='Straight')
        type=1;
      else if(name==='Left')
        type = 2;
      else if (name==='Right')
        type = 3;
      else if(name==='ZigZagLeft')
        type = 4;
      else if (name==='ZigZagRight')
        type = 5;
      else if(name==='Horn')
        type = 9;
      else if (name==='Left_Signal')
        type = 10;
      else if(name==='Right_Signal')
        type = 11;
      else if (name==='Hazard')
        type = 12;
      controlData.CodeToExecute.push(type);
      console.log(controlData.CodeToExecute);
      console.log("Added to list: "+self.core.getAttribute(dstNode,'name'));

    }
    }

    //Function to load destination in non codetoexecute path
              function atDestinationControl(connection) {

                  return function (err, dstControl) {
                      console.log('In atDestinationControl(connection), length = ' + controlData.Connections.length);
                      if (err) {
                          error = new Error(err);
                      } else {
                          if(controlData.Connections.length >= 1) {

                              self.logger.error('Multiple Incoming connections: ' + controlData.Connections.length);
                              deferred.reject(new Error('Multiple Incoming connections: ' + controlData.Connections.length));
                              return;
                          }
                          controlData.Connections.push({
      //											distance: self.core.getAttribute(connection, 'Distance'),
      //											velocity: self.core.getAttribute(connection, 'Velocity'),
                              targetId: self.core.getPath(dstControl),
                              targetName: self.core.getAttribute(dstControl, 'name'),
                          });
                      }

                      counter -= 1;
                      if (counter === 0) {
                          if (error) {
                              deferred.reject(error);
                          } else {
                              deferred.resolve(controlData);
                          }
                        }
                      }
                    }
                    //Sets attributes of each control block sets type and times
                    if (self.core.getAttribute(abstractControlBlock,'name')==='For') {
                      console.log('FOR LOOP');
                      controlData.Type = 6;
                      controlData.Times = self.core.getAttribute(abstractControlBlock,'times');
                  }
                  else if(self.core.getAttribute(abstractControlBlock,'name')==='While')
                  {
                    console.log('While LOOP');
                    //Sets condition number and type for while
                    var condition= self.core.getAttribute(abstractControlBlock,'condition');
                    let condNum=-1;
                    if(condition==="SafeLeft")
                    {
                      condNum = 1;
                    }
                    else if(condition==="SafeStraight")
                    {
                      condNum = 2;
                    }
                    else
                    {
                      condNum = 3;
                    }
                    controlData.Condition = condNum;
                    controlData.Type = 7;
                  }
                  //Sets type and condition number for If
                  else if(self.core.getAttribute(abstractControlBlock,'name')==='If')
                  {
                    console.log('If');
                    var condition= self.core.getAttribute(abstractControlBlock,'condition');
                    let condNum=-1;
                    if(condition==="SafeLeft")
                    {
                      condNum = 1;
                    }
                    else if(condition==="SafeStraight")
                    {
                      condNum = 2;
                    }
                    else
                    {
                      condNum = 3;
                    }
                    controlData.Condition = condNum;
                    controlData.Type = 8;
                  }
                  // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
                  self.core.loadCollection(abstractControlBlock, 'src', function (err, connections) {
                      if (err) {
                          deferred.reject(new Error(err));
                          return;
                      }
                      var i;
                      counter = connections.length;

                      if(connections.length > 1) {
                          self.logger.error('Multiple outgoing connections: ' + connections.length);
                          deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                          return;
                      }
                      // For each connection load the destination state.
                      for (i = 0; i < connections.length; i += 1) {
                          self.core.loadPointer(connections[i], 'dst', atDestinationControl(connections[i]));
                      }

                      // Make sure to resolve when there are no connections.
                      if (connections.length === 0) {
                          deferred.resolve(controlData);
                      }
                  });
                  self.core.loadCollection(abstractControlBlock, 'dst', function (err, connections) {
                      if (err) {
                          deferred.reject(new Error(err));
                          return;
                      }
                      if(connections.length > 1) {
                          self.logger.error('Multiple incoming connections: ' + connections.length);
                          deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                          return;
                      } else if(connections.length == 0) {
                          console.log('Found the starting control: ' + self.core.getPath(abstractControlBlock));
                          controlData.isStart = true;
                      }
                  });

                  return deferred.promise;
    }
    //Definition of action block and builds connection to next node
        CATVehicleContinuousVerifier.prototype.getActionData= function(abstractActionBlock)
        {
          var self = this,
              deferred = new Q.defer(),
              actionData = {
                  id: self.core.getPath(abstractActionBlock),
                  name: self.core.getAttribute(abstractActionBlock, 'name'),
                  isStart: false,
                  Connections: [
                      // event: <string>
                      // targetId: <nodePathStr>
                  ]
              },
              error,
              counter;
              function atDestinationAction(connection) {

                  return function (err, dstAction) {
                      console.log('In atDestinationAction(connection), length = ' + actionData.Connections.length);
                      if (err) {
                          error = new Error(err);
                      } else {
                          if(actionData.Connections.length >= 1) {

                              self.logger.error('Multiple Incoming connections: ' + actionData.Connections.length);
                              deferred.reject(new Error('Multiple Incoming connections: ' + actionData.Connections.length));
                              return;
                          }
                          actionData.Connections.push({
      //											distance: self.core.getAttribute(connection, 'Distance'),
      //											velocity: self.core.getAttribute(connection, 'Velocity'),
                              targetId: self.core.getPath(dstAction),
                              targetName: self.core.getAttribute(dstAction, 'name'),
                          });
                      }

                      counter -= 1;
                      if (counter === 0) {
                          if (error) {
                              deferred.reject(error);
                          } else {
                              deferred.resolve(actionData);
                          }

                                    }
                                  }
                                }
                                if (self.core.getAttribute(abstractActionBlock,'name')==='Horn') {
                                  console.log('Horn');
                                  actionData.Type = 9;
                              }
                              else if(self.core.getAttribute(abstractActionBlock,'name')==='Left_Signal')
                              {
                                  console.log('Left Signal');
                                actionData.Type = 10;
                              }
                              else if(self.core.getAttribute(abstractActionBlock,'name')==='Right_Signal')
                              {
                                  console.log('Right Signal');
                                actionData.Type = 11;
                              }
                              else if(self.core.getAttribute(abstractActionBlock,'name')==='Hazard')
                              {
                                  console.log('Hazard');
                                actionData.Type = 12;
                              }
                              self.core.loadCollection(abstractActionBlock, 'src', function (err, connections) {
                                  if (err) {
                                      deferred.reject(new Error(err));
                                      return;
                                  }
                                  var i;
                                  counter = connections.length;

                                  if(connections.length > 1) {
                                      self.logger.error('Multiple outgoing connections: ' + connections.length);
                                      deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                                      return;
                                  }
                                  // For each connection load the destination state.
                                  for (i = 0; i < connections.length; i += 1) {
                                      self.core.loadPointer(connections[i], 'dst', atDestinationAction(connections[i]));
                                  }

                                  // Make sure to resolve when there are no connections.
                                  if (connections.length === 0) {
                                      deferred.resolve(actionData);
                                  }
                              });
                              self.core.loadCollection(abstractActionBlock, 'dst', function (err, connections) {
                                  if (err) {
                                      deferred.reject(new Error(err));
                                      return;
                                  }
                                  if(connections.length > 1) {
                                      self.logger.error('Multiple incoming connections: ' + connections.length);
                                      deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                                      return;
                                  } else if(connections.length == 0) {
                                      console.log('Found the starting motion: ' + self.core.getPath(abstractActionBlock));
                                      actionData.isStart = true;
                                  }
                              });

                              return deferred.promise;
        }
        //Definition of a motion node and builds connection to next node
        CATVehicleContinuousVerifier.prototype.getMotionData = function(PrimitiveMotionNode) {
            var self = this,
                deferred = new Q.defer(),
                motionData = {
                    id: self.core.getPath(PrimitiveMotionNode),
                    name: self.core.getAttribute(PrimitiveMotionNode, 'name'),
                    isStart: false,
                    //distance: self.core.getAttribute(PrimitiveMotionNode, 'Distance'),
                    velocity: self.core.getAttribute(PrimitiveMotionNode, 'Velocity'),
                    Connections: [
                        // event: <string>
                        // targetId: <nodePathStr>
                    ]
                },
                error,
                counter;
            function atDestinationMotion(connection) {

                return function (err, dstMotion) {
                    console.log('In atDestinationMotion(connection), length = ' + motionData.Connections.length);
                    if (err) {
                        error = new Error(err);
                    } else {
                        if(motionData.Connections.length >= 1) {

                            self.logger.error('Multiple Incoming connections: ' + motionData.Connections.length);
                            deferred.reject(new Error('Multiple Incoming connections: ' + motionData.Connections.length));
                            return;
                        }

                        motionData.Connections.push({
    //											distance: self.core.getAttribute(connection, 'Distance'),
    //											velocity: self.core.getAttribute(connection, 'Velocity'),
                            targetId: self.core.getPath(dstMotion),
                            targetName: self.core.getAttribute(dstMotion, 'name'),
                        });
                    }

                    counter -= 1;
                    if (counter === 0) {
                        if (error) {
                            deferred.reject(error);
                        } else {
                            deferred.resolve(motionData);
                        }
                    }
                }
            }

            if (self.core.getAttribute(PrimitiveMotionNode,'name')==='Straight') {
                console.log('STRAIGHT!!!!');
                motionData.Type = 1;
                motionData.RadOfCurvature = 0;
                motionData.Distance = self.core.getAttribute(PrimitiveMotionNode, 'Distance');
                motionData.FinalTurnAngle = 0;
            } else if (self.core.getAttribute(PrimitiveMotionNode,'name')==='Left') {
              console.log("Left");
                motionData.Type = 2;
                motionData.RadOfCurvature = self.core.getAttribute(PrimitiveMotionNode, 'RadOfCurvature');
                motionData.Distance = 0;
                motionData.FinalTurnAngle = self.core.getAttribute(PrimitiveMotionNode, 'FinalTurnAngle');
            } else if (self.core.getAttribute(PrimitiveMotionNode,'name')==='Right') {
              console.log("Right");
                motionData.Type = 3;
                motionData.RadOfCurvature = self.core.getAttribute(PrimitiveMotionNode, 'RadOfCurvature');
                motionData.Distance = 0;
                motionData.FinalTurnAngle = self.core.getAttribute(PrimitiveMotionNode, 'FinalTurnAngle');
            } else if (self.core.getAttribute(PrimitiveMotionNode,'name')==='ZigZagLeft') {
              console.log("ZigZagLeft");
                motionData.Type = 4;
                motionData.RadOfCurvature = 0;
                motionData.Distance = 0;
                motionData.FinalTurnAngle = 0;
            } else if (self.core.getAttribute(PrimitiveMotionNode,'name')==='ZigZagRight') {
              console.log("ZigZagRight");
                motionData.Type = 5;
                motionData.RadOfCurvature = 0;
                motionData.Distance = 0;
                motionData.FinalTurnAngle = 0;
            }

            // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
            self.core.loadCollection(PrimitiveMotionNode, 'src', function (err, connections) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }
                var i;
                counter = connections.length;

                if(connections.length > 1) {
                    self.logger.error('Multiple outgoing connections: ' + connections.length);
                    deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                    return;
                }

                // For each connection load the destination state.
                for (i = 0; i < connections.length; i += 1) {
                    self.core.loadPointer(connections[i], 'dst', atDestinationMotion(connections[i]));
                }

                // Make sure to resolve when there are no connections.
                if (connections.length === 0) {
                    deferred.resolve(motionData);
                }
            });

            // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
            self.core.loadCollection(PrimitiveMotionNode, 'dst', function (err, connections) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }
                if(connections.length > 1) {
                    self.logger.error('Multiple incoming connections: ' + connections.length);
                    deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                    return;
                } else if(connections.length == 0) {
                    console.log('Found the starting motion: ' + self.core.getPath(PrimitiveMotionNode));
                    motionData.isStart = true;
                }
            });

            return deferred.promise;

        }
        //Builds the path model to be used with all the blocks loaded in as children of the path
        CATVehicleContinuousVerifier.prototype.extractDataModel = function (path,callback) {
            var self = this,
                deferred = new Q.defer(),
                //definition of data and path models
                dataModel = {
                    pathModel: {
                        name: '',
                        //initialState: null,
                        //finalStates: [],
                        startX: self.core.getAttribute(path, 'startX'),
                        startY: self.core.getAttribute(path, 'startY'),
                        startDirection: self.core.getAttribute(path, 'startDirection'),
                        endX: self.core.getAttribute(path, 'endX'),
                        endY: self.core.getAttribute(path, 'endY'),
                        endDirection: self.core.getAttribute(path, 'endDirection'),
                        obstacleY: self.core.getAttribute(path, 'obstacleY'),
                        obstacleX: self.core.getAttribute(path, 'obstacleX'),
                        motion: [
                            //id: <nodePathStr>
                            //name: <string>
                            //events: []
                        ]
                    }
                };

            self.logger.info('In extractDataModel()');
            dataModel.pathModel.name = self.core.getAttribute(path, 'name');
            self.logger.info('- extractDataModel() : Path name = ' + dataModel.pathModel.name);

            self.core.loadChildren(path, function (err, children) {
                console.log('self.core.loadChildren(pathNode, function (err, children) {}');
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }

                var primitivePromises = [],
                    i,
                    metaType;
    //Loads all of the blocks who are children of the path
    self.logger.info("Length of children of path: "+children.length);
                for (i = 0; i < children.length; i += 1) {
                    //metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                    //self.logger.info(' - metaType = ' + metaType);
                    self.logger.info("Block is "+self.core.getAttribute(children[i],'name'));
                    //Metatype is not working idk y
                    //self.logger.info("Metatype of block is "+self.getMetaType(children[i],'name'));
                    var name = self.core.getAttribute(children[i],'name');
                    if (name ==='Straight'||name ==='Left'||name ==='Right'||name ==='ZigZagLeft'||name ==='ZigZagRight') {
                        self.logger.info(' - Found primitive motion!');
                        primitivePromises.push(self.getMotionData(children[i]));
                        //metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                        //self.logger.info(' - metaType = ' + metaType);
                    }
                    else if(name ==='If'||name==='While'||name==='For')
                    {
                      self.logger.info(' - Found primitive control!');
                      primitivePromises.push(self.getControlData(children[i]));
                      //metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                      //self.logger.info(' - metaType = ' + metaType);
                    }
                    else if(name==='Horn'||name==='Right_Signal'||name==='Left_Signal'||name==='Hazard')
                    {
                      self.logger.info(' - Found primitive action!');
                      primitivePromises.push(self.getActionData(children[i]));
                      //metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                      //self.logger.info(' - metaType = ' + metaType);
                    }
                }
    //Asynch fixing waiting for all blocks to execute in proper order
                Q.all(primitivePromises)
                    .then(function (primitiveData) {
                        self.logger.info('Q.all(primitivePromises).then(function (primitiveData){}');
                        dataModel.pathModel.motion = primitiveData;
                        deferred.resolve(dataModel);
                    })
                    .catch(deferred.reject);

                //console.log('generateDataModel :dataModel: ' + JSON.stringify(dataModel, null, 4));
                return deferred.promise;

            });''

            return deferred.promise;

            // return this.core.loadSubTree(self.activeNode)
            //     .then(function (nodes) {
            //         self.logger.info('In loadSubTree().then()');
            //         return dataModel;
            //     })
            //     .nodeify(callback);
        }
    CATVehicleContinuousVerifier.prototype.letterToNumber = function (theLetter) {
        switch(theLetter) {
            case "A":
                return 0;
            case "B":
                return 1;
            case "C":
                return 2;
            case "D":
                return 3;
	    case "E":
		return 4;
        }
        return -999;
    };

    CATVehicleContinuousVerifier.prototype.modelCheck = function (dModel) {
        var self = this,
            motion = {},
            dataModel = dModel,
            pathModel = dModel.pathModel,
            haveMotion = false,
            deferred = new Q.defer(),
            i,
            gridSize = 4,
            minNumberOfMoves = 6,
            maxNumberOfMoves = 100,
            count = 1,
            currentX,
            currentY,
            expectedX,
            expectedY,
            currentDirection = pathModel.startDirection;

        self.logger.info('In modelCheck()');
        // Convert the calues to what the class expects:
        currentX = self.letterToNumber(pathModel.startX);
        if(currentX < 0) {
            deferred.reject(new Error('Unknown startX = ' + pathModel.startX));
            return deferred.promise;
        }
        currentY = gridSize - pathModel.startY;
        expectedX = self.letterToNumber(pathModel.endX);
        if(currentX < 0) {
            deferred.reject(new Error('Unknown endX = ' + pathModel.endX));
            return deferred.promise;
        }
        expectedY = gridSize - pathModel.endY;

        for (i = 0; i < pathModel.motion.length; i += 1) {
            if(pathModel.motion[i].isStart) {
                motion = pathModel.motion[i];
                haveMotion = true;
                break;
            }
        }

        while(haveMotion) {
            //console.log('Have a motion: ' + JSON.stringify(motion, null, 4));
            //console.log(' - PrimitiveMotionConnections: ' + JSON.stringify(motion.PrimitiveMotionConnections, null, 4));
            var priorPosition = '(' + currentX + ',' + currentY + ') : ' + currentDirection
            switch(motion.Type) {
                case 1:	// Straight
                    //currentDirection = currentDirection;	// won't change
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            break;
                        case "W":
                            currentX -= 1;
                            break;
                        case "N":
                            currentY += 1;
                            break;
                        case "S":
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 2:	// Left
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY += 1;
                            currentDirection = "N";
                            break;
                        case "W":
                            currentX -= 1;
                            currentY -= 1;
                            currentDirection = "S";
                            break;
                        case "N":
                            currentX -= 1;
                            currentY += 1;
                            currentDirection = "W";
                            break;
                        case "S":
                            currentX += 1;
                            currentY -= 1;
                            currentDirection = "E";
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 3:	// Right
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY -= 1;
                            currentDirection = "S";
                            break;
                        case "W":
                            currentX -= 1;
                            currentY += 1;
                            currentDirection = "N";
                            break;
                        case "N":
                            currentX += 1;
                            currentY += 1;
                            currentDirection = "E";
                            break;
                        case "S":
                            currentX -= 1;
                            currentY -= 1;
                            currentDirection = "W";
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 4:	// ZigZagLeft
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY += 1;
                            break;
                        case "W":
                            currentX -= 1;
                            currentY -= 1;
                            break;
                        case "N":
                            currentX -= 1;
                            currentY += 1;
                            break;
                        case "S":
                            currentX += 1;
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 5:	// ZigZagRight
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY -= 1;
                            break;
                        case "W":
                            currentX -= 1;
                            currentY += 1;
                            break;
                        case "N":
                            currentX += 1;
                            currentY += 1;
                            break;
                        case "S":
                            currentX -= 1;
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                    case 6://For loop
                    {
                      var iter = motion.Times;
                      var i;
                      for(i=0;i<iter;i+=1)
                      {
                        var j;
                        for(j = 0; j<motion.CodeToExecute.length;j+=1)
                        {
                          if(motion.CodeToExecute[j]===1)
                          {
                            switch(currentDirection) {
                                case "E":
                                    currentX += 1;
                                    break;
                                case "W":
                                    currentX -= 1;
                                    break;
                                case "N":
                                    currentY += 1;
                                    break;
                                case "S":
                                    currentY -= 1;
                                    break;
                                default:
                                    deferred.reject(new Error('Unknown direction!'));
                                    return deferred.promise;
                            }
                          }
                          else if(motion.CodeToExecute[j]===2)
                          {
                            switch(currentDirection) {
                                case "E":
                                    currentX += 1;
                                    currentY += 1;
                                    currentDirection = "N";
                                    break;
                                case "W":
                                    currentX -= 1;
                                    currentY -= 1;
                                    currentDirection = "S";
                                    break;
                                case "N":
                                    currentX -= 1;
                                    currentY += 1;
                                    currentDirection = "W";
                                    break;
                                case "S":
                                    currentX += 1;
                                    currentY -= 1;
                                    currentDirection = "E";
                                    break;
                                default:
                                    deferred.reject(new Error('Unknown direction!'));
                                    return deferred.promise;
                            }
                          }
                          else if(motion.CodeToExecute[j]===3)
                          {
                            switch(currentDirection) {
                                case "E":
                                    currentX += 1;
                                    currentY -= 1;
                                    currentDirection = "S";
                                    break;
                                case "W":
                                    currentX -= 1;
                                    currentY += 1;
                                    currentDirection = "N";
                                    break;
                                case "N":
                                    currentX += 1;
                                    currentY += 1;
                                    currentDirection = "E";
                                    break;
                                case "S":
                                    currentX -= 1;
                                    currentY -= 1;
                                    currentDirection = "W";
                                    break;
                                default:
                                    deferred.reject(new Error('Unknown direction!'));
                                    return deferred.promise;
                            }
                          }
                          else if(motion.CodeToExecute[j]===4)
                          {
                            switch(currentDirection) {
                                case "E":
                                    currentX += 1;
                                    currentY += 1;
                                    break;
                                case "W":
                                    currentX -= 1;
                                    currentY -= 1;
                                    break;
                                case "N":
                                    currentX -= 1;
                                    currentY += 1;
                                    break;
                                case "S":
                                    currentX += 1;
                                    currentY -= 1;
                                    break;
                                default:
                                    deferred.reject(new Error('Unknown direction!'));
                                    return deferred.promise;
                            }
                          }
                          else if(motion.CodeToExecute[j]===5)
                          {
                            switch(currentDirection) {
                                case "E":
                                    currentX += 1;
                                    currentY -= 1;
                                    break;
                                case "W":
                                    currentX -= 1;
                                    currentY += 1;
                                    break;
                                case "N":
                                    currentX += 1;
                                    currentY += 1;
                                    break;
                                case "S":
                                    currentX -= 1;
                                    currentY -= 1;
                                    break;
                                default:
                                    deferred.reject(new Error('Unknown direction!'));
                                    return deferred.promise;
                            }
                          }
                        }
                      }
                    }
                    break;
                    case 7://while loop
                    {
                      var tempX = currentX;
                      var tempY = currentY;
                      if(motion.condNum===1)
                      {
                        switch(currentDirection) {
                            case "E":
                                tempX += 1;
                                tempY += 1;
                                break;
                            case "W":
                                tempX -= 1;
                                tempY -= 1;
                                break;
                            case "N":
                                tempX -= 1;
                                tempY += 1;
                                break;
                            case "S":
                                tempX += 1;
                                tempY -= 1;
                                break;
                            default:
                                deferred.reject(new Error('Unknown direction!'));
                                return deferred.promise;
                        }
                      }
                      else if(motion.condNum===2)
                      {
                        switch(currentDirection) {
                            case "E":
                                tempX += 1;
                                break;
                            case "W":
                                tempX -= 1;
                                break;
                            case "N":
                                tempY += 1;
                                break;
                            case "S":
                                tempY -= 1;
                                break;
                            default:
                                deferred.reject(new Error('Unknown direction!'));
                                return deferred.promise;
                        }
                      }
                      else if(motion.condNum===3)
                      {
                        switch(currentDirection) {
                            case "E":
                                tempX += 1;
                                tempY -= 1;

                                break;
                            case "W":
                                tempX -= 1;
                                tempY += 1;

                                break;
                            case "N":
                                tempX += 1;
                                tempY += 1;

                                break;
                            case "S":
                                tempX -= 1;
                                tempY -= 1;

                                break;
                            default:
                                deferred.reject(new Error('Unknown direction!'));
                                return deferred.promise;
                        }
                      }

                      while((tempX != self.letterToNumber(pathModel.obstacleX) && tempY != (gridSize-pathModel.obstacleY))&&currentX>=0&&currentY>=0&&currentX <= gridSize-1&&currentY <= gridSize-1) {
                      self.logger.info("While returned true");
                      for(j = 0; j<motion.CodeToExecute.length;j+=1)
                      {
                        if(motion.CodeToExecute[j]===1)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  break;
                              case "W":
                                  currentX -= 1;
                                  break;
                              case "N":
                                  currentY += 1;
                                  break;
                              case "S":
                                  currentY -= 1;
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===2)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY += 1;
                                  currentDirection = "N";
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY -= 1;
                                  currentDirection = "S";
                                  break;
                              case "N":
                                  currentX -= 1;
                                  currentY += 1;
                                  currentDirection = "W";
                                  break;
                              case "S":
                                  currentX += 1;
                                  currentY -= 1;
                                  currentDirection = "E";
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===3)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY -= 1;
                                  currentDirection = "S";
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY += 1;
                                  currentDirection = "N";
                                  break;
                              case "N":
                                  currentX += 1;
                                  currentY += 1;
                                  currentDirection = "E";
                                  break;
                              case "S":
                                  currentX -= 1;
                                  currentY -= 1;
                                  currentDirection = "W";
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===4)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY += 1;
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY -= 1;
                                  break;
                              case "N":
                                  currentX -= 1;
                                  currentY += 1;
                                  break;
                              case "S":
                                  currentX += 1;
                                  currentY -= 1;
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===5)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY -= 1;
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY += 1;
                                  break;
                              case "N":
                                  currentX += 1;
                                  currentY += 1;
                                  break;
                              case "S":
                                  currentX -= 1;
                                  currentY -= 1;
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                    }
                    tempX = currentX;
                    tempY = currentY;
                    if(motion.condNum===1)
                    {
                      switch(currentDirection) {
                          case "E":
                              tempX += 1;
                              tempY += 1;
                              break;
                          case "W":
                              tempX -= 1;
                              tempY -= 1;
                              break;
                          case "N":
                              tempX -= 1;
                              tempY += 1;
                              break;
                          case "S":
                              tempX += 1;
                              tempY -= 1;
                              break;
                          default:
                              deferred.reject(new Error('Unknown direction!'));
                              return deferred.promise;
                      }
                    }
                    else if(motion.condNum===2)
                    {
                      switch(currentDirection) {
                          case "E":
                              tempX += 1;
                              break;
                          case "W":
                              tempX -= 1;
                              break;
                          case "N":
                              tempY += 1;
                              break;
                          case "S":
                              tempY -= 1;
                              break;
                          default:
                              deferred.reject(new Error('Unknown direction!'));
                              return deferred.promise;
                      }
                    }
                    else if(motion.condNum===3)
                    {
                      switch(currentDirection) {
                          case "E":
                              tempX += 1;
                              tempY -= 1;

                              break;
                          case "W":
                              tempX -= 1;
                              tempY += 1;

                              break;
                          case "N":
                              tempX += 1;
                              tempY += 1;

                              break;
                          case "S":
                              tempX -= 1;
                              tempY -= 1;

                              break;
                          default:
                              deferred.reject(new Error('Unknown direction!'));
                              return deferred.promise;
                      }
                    }
                    }
                  }
                    break;
                    case 8://If statement
                    {
                      var tempX = currentX;
                      var tempY = currentY;
                      if(motion.condNum===1)
                      {
                        switch(currentDirection) {
                            case "E":
                                tempX += 1;
                                tempY += 1;
                                break;
                            case "W":
                                tempX -= 1;
                                tempY -= 1;
                                break;
                            case "N":
                                tempX -= 1;
                                tempY += 1;
                                break;
                            case "S":
                                tempX += 1;
                                tempY -= 1;
                                break;
                            default:
                                deferred.reject(new Error('Unknown direction!'));
                                return deferred.promise;
                        }
                      }
                      else if(motion.condNum===2)
                      {
                        switch(currentDirection) {
                            case "E":
                                tempX += 1;
                                break;
                            case "W":
                                tempX -= 1;
                                break;
                            case "N":
                                tempY += 1;
                                break;
                            case "S":
                                tempY -= 1;
                                break;
                            default:
                                deferred.reject(new Error('Unknown direction!'));
                                return deferred.promise;
                        }
                      }
                      else if(motion.condNum===3)
                      {
                        switch(currentDirection) {
                            case "E":
                                tempX += 1;
                                tempY -= 1;

                                break;
                            case "W":
                                tempX -= 1;
                                tempY += 1;

                                break;
                            case "N":
                                tempX += 1;
                                tempY += 1;

                                break;
                            case "S":
                                tempX -= 1;
                                tempY -= 1;

                                break;
                            default:
                                deferred.reject(new Error('Unknown direction!'));
                                return deferred.promise;
                        }
                      }
                      if( tempX == self.letterToNumber(pathModel.obstacleX) && tempY == (gridSize-pathModel.obstacleY)) {
                        self.logger.info("If returned false");
                  	}
                    else
                    {
                      self.logger.info("If returned true");
                      for(j = 0; j<motion.CodeToExecute.length;j+=1)
                      {
                        if(motion.CodeToExecute[j]===1)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  break;
                              case "W":
                                  currentX -= 1;
                                  break;
                              case "N":
                                  currentY += 1;
                                  break;
                              case "S":
                                  currentY -= 1;
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===2)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY += 1;
                                  currentDirection = "N";
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY -= 1;
                                  currentDirection = "S";
                                  break;
                              case "N":
                                  currentX -= 1;
                                  currentY += 1;
                                  currentDirection = "W";
                                  break;
                              case "S":
                                  currentX += 1;
                                  currentY -= 1;
                                  currentDirection = "E";
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===3)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY -= 1;
                                  currentDirection = "S";
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY += 1;
                                  currentDirection = "N";
                                  break;
                              case "N":
                                  currentX += 1;
                                  currentY += 1;
                                  currentDirection = "E";
                                  break;
                              case "S":
                                  currentX -= 1;
                                  currentY -= 1;
                                  currentDirection = "W";
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===4)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY += 1;
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY -= 1;
                                  break;
                              case "N":
                                  currentX -= 1;
                                  currentY += 1;
                                  break;
                              case "S":
                                  currentX += 1;
                                  currentY -= 1;
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                        else if(motion.CodeToExecute[j]===5)
                        {
                          switch(currentDirection) {
                              case "E":
                                  currentX += 1;
                                  currentY -= 1;
                                  break;
                              case "W":
                                  currentX -= 1;
                                  currentY += 1;
                                  break;
                              case "N":
                                  currentX += 1;
                                  currentY += 1;
                                  break;
                              case "S":
                                  currentX -= 1;
                                  currentY -= 1;
                                  break;
                              default:
                                  deferred.reject(new Error('Unknown direction!'));
                                  return deferred.promise;
                          }
                        }
                    }
                    }
                  }
                    break;
                default:
                    deferred.reject(new Error('Unknown motion!'));
                    return deferred.promise;
            }

            console.log( priorPosition + ' [' + motion.Type + ']-> (' + currentX + ',' + currentY + ') : ' + currentDirection);

            if(currentX < 0) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far West!'));
                return deferred.promise;
            } else if(currentX > gridSize-1) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far East!'));
                return deferred.promise;
            }
            if(currentY < 0) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far South!'));
                return deferred.promise;
            } else if(currentY > gridSize-1) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far North!'));
                return deferred.promise;
            }
	self.logger.info('currentX = ' + currentX + '  obstacleX: ' + self.letterToNumber(pathModel.obstacleX));
	self.logger.info('currentY = ' + currentY + '  obstacleY: ' + (gridSize-pathModel.obstacleY));
		if( currentX == self.letterToNumber(pathModel.obstacleX) && currentY == (gridSize-pathModel.obstacleY)) {
                deferred.reject(new Error('Ran into an obstacle on motion #' + count ));
                return deferred.promise;

	}

            haveMotion = false;
            count += 1;
            if( motion.Connections.length != 0) {
                console.log('There exists an outgoing connection');

                for (i = 0; i < pathModel.motion.length; i += 1) {
                    if(pathModel.motion[i].id === motion.Connections[0].targetId) {
                        haveMotion = true;
                        motion = pathModel.motion[i];
                        break;
                    }
                }
            }
        }
/**
	if( count-1 < minNumberOfMoves ) {
		deferred.reject(new Error('Not enough moves!  you more than ' + minNumberOfMoves + ' moves, you have ' + (count-1) + ' moves.'));
                return deferred.promise;

	}
	if( count-1 > maxNumberOfMoves ) {
		deferred.reject(new Error('Too many moves!  you less than ' + maxNumberOfMoves + ' moves, you have ' + (count-1) + ' moves.'));
                return deferred.promise;

	}


        if(expectedX != currentX ||
            expectedY != currentY ||
            pathModel.endDirection !== currentDirection) {
            var errorString = 'Expected end at: ' + self.numberToLetter(expectedX) + (gridSize - expectedY) + ' facing ' + pathModel.endDirection;
            errorString += ', Actually ended at: ' + self.numberToLetter(currentX) + (gridSize - currentY) + ' facing ' + currentDirection;
            errorString += ', The start is: ' + pathModel.startX + pathModel.startY + ' facing ' + pathModel.startDirection;

            console.log('Model check Failed');
            deferred.reject(new Error('The end was not reached from the start! ' + errorString));
            return deferred.promise;
        }
**/
        deferred.resolve(dataModel);

        return deferred.promise;
    };
    /**
     * This is invoked each time changes in the branch of the project are done. AddOns are allowed to make changes on
     * an update, but should not persist by themselves. (The AddOnManager will persist after each addOn has had its way
     * ordered by the usedAddOn registry in the rootNode).
     * Before each invocation a new updateResult is created which should be returned in the callback. There is no need
     * for the AddOn to report if it made changes or not, the monitor/manager will always persist and if there are no
     * changed objects - it won't commit to the storage.
     * @param {object} rootNode
     * @param {object} commitObj
     * @param {function(Error, AddOnUpdateResult)} callback
     */
    CATVehicleContinuousVerifier.prototype.update = function (rootNode, commitObj, callback) {
      var self = this,
          deferred = new Q.defer(),
          nodeObject;
        var newName = commitObj.updater.toString();
        this.logger.info('CATVehicleContinuousVerifier in update at commitHash', commitObj._id);
        //Root node is Guest
        this.logger.info('Root node is '+self.core.getAttribute(rootNode,'name'));
        //Throws error
        //this.logger.info('Active node is '+self.core.getAttribute(self.activeNode,'name'));
        if (this.core.getAttribute(rootNode, 'name') !== newName) {
            this.logger.info('CATVehicleContinuousVerifier changing name of root to committer(s): ', newName);
            this.core.setAttribute(rootNode, 'name', newName);
            this.addCommitMessage('Changed rootNode name to "' + newName + '"');
        }
        self.core.loadChildren(rootNode, function (err, children) {
  if (err) {
     // Something went wrong!
     // Handle the error and return.
     self.logger.error("Error loading children");
  }
  // We have an array of the children and can get information from them.
  var i;
  for (i = 0; i < children.length; i += 1) {
    if(self.core.getAttribute(children[i],'name')==='aPath')
    {
  self.logger.info("Child path is "+self.core.getAttribute(children[i], 'name'));
  self.extractDataModel(children[i])
      .then(function (dataModel) {
          //self.logger.info(JSON.stringify(dataModel, null, 4));
          self.logger.info('generateDataModel().then(): dataModel: ' + JSON.stringify(dataModel, null, 4));

                  return self.modelCheck(dataModel);
              })
              .then(function () {
                  //  console.log('generateDataModel().then().then(): dataModel: ' + JSON.stringify(dataModel, null, 4));
                  self.logger.info('In success part');

                })
                .catch(function (err) {
                    self.logger.error(err);
                })
                .done();
}
}
});
callback(null, this.updateResult);
}
    /**
     * Called once when the addOn is started for the first time.
     * @param {object} rootNode
     * @param {object} commitObj
     * @param {function(Error, AddOnUpdateResult} callback
     */
    CATVehicleContinuousVerifier.prototype.initialize = function (rootNode, commitObj, callback) {
        this.logger.info('CATVehicleContinuousVerifier got initialized at commitHash', commitObj._id);

        this.update(rootNode, commitObj, callback);
    };

    return CATVehicleContinuousVerifier;
});
