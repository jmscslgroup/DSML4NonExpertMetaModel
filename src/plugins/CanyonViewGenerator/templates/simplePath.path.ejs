<%_
// First we have to format the JSON object into a form that works for us. We need to create a couple
// of structs to hold places and pointers. The general idea of this is that we need to organize this JSON
// object into the correct ordering for the program to work. If we can do that then we can use stacks and
// stuff to keep a "stack frame" when we need to unravel.

// Find the root node
let rootPath = ""
for(let block in blocks) {
    let blockPath = blocks[block]["type"]
    let connections = blocks[block]["connections"]
    if( !connections["In"] ) {
        rootPath = JSON.stringify(block)
        rootPath = rootPath.substring(1, rootPath.length-1);
    }
}
console.info("Found root node at: " + rootPath);

// Execute down the tree until all paths are exhausted
let done = false;
let programStack = [];
let currentPath = rootPath;
let limit = 0;
let unclosedBrackets = 0;
while( !done && limit <= 500) {
    limit += 1
    // Get the type of the current block
    let currBlockType = blocks[currentPath]["type"];
    console.info("Current node " + currentPath + " is of type " + currBlockType);

    // Execute the current block
    exportCommand(currentPath);

    // Check if the current block is of a special type
    if( currBlockType == "For" ) {
        // If the block is a for push it to the program stack and then go down the code to execute route
        console.info("Pushing for and falling into for block");
        programStack.push(currentPath);
        currentPath = blocks[currentPath]["connections"]["Code to Execute"];
        continue;
    } else if ( currBlockType == "If/Else" ) {
        // If the block is an if push it to the program stack and then go down the true path
        console.info("Pushing if and falling into if/else true block");
        programStack.push(currentPath);
        currentPath = blocks[currentPath]["connections"]["Out if True"];
        continue;
    } else if ( currBlockType == "If" ) {
        // If the block is an if push it to the program stack and then go down the true path
        console.info("Pushing if and falling into if true block");
        programStack.push(currentPath);
        currentPath = blocks[currentPath]["connections"]["Truthy Out"];
        continue;
    }

    // Check if the current child has no children. This is the case in only two situations:
    // 1) the program has ended - This is only true if the stack is also empty
    // 2) the current path is exhausted - This is true when the stack is ! empty
    if( !blocks[currentPath]["connections"]["Out"] ){
        // Try and pop from program stack
        if( programStack.length != 0 ) {
            console.info("Current block has no children but the stack is not empty... Popping");
            // POP and check the type of the pop
            let popPath = programStack.pop();
            let popBlockType = blocks[popPath]["type"];

            if ( popBlockType == "For" ) {
                // If the popped block is a for then we just start going down the "out" path
                currentPath = blocks[popPath]["connections"]["Out"];
                closeBrackets(popBlockType);
                console.info("Popping back to the last For block at " + currentPath);
            } else if ( popBlockType == "If/Else" ) {
                // TODO: Put an else
                // If the popped block is an if then we just start going down the "out if false" path
                currentPath = blocks[popPath]["connections"]["Out if False"]
                closeBrackets(popBlockType);
                console.info("Popping back to the last If/Else block at " + currentPath);
            }
            else if ( popBlockType == "If" ) {
                // TODO: Put an else
                // If the popped block is an if then we just start going down the "out if false" path
                currentPath = blocks[popPath]["connections"]["After"]
                closeBrackets(popBlockType);
                console.info("Popping back to the last If block at " + currentPath);
            }

        }
        else {
            // If there is no child and no pop-able things then we are donezo
            console.info("No more children and no more stuff to pop. Exiting");
            done = true;
        }
    } else {
        // If the block does have children then the current path is just the child
        currentPath = blocks[currentPath]["connections"]["Out"];
        console.info("Traversing to block's child at " + currentPath);
    }
}

closeUnclosedBrackets();
   function closeBrackets(blockType) {
       if( blockType == "If/Else") {
            unclosedBrackets+=1 %>
} else {
<%_     } else if ( blockType == "For" || blockType == "If") { %>
}
<%_ }
} %>
<%_ function closeUnclosedBrackets() {
    for(let i = 0; i < unclosedBrackets; i++) { %>
}
<%_ }
} %>
<%_ function exportCommand(blockPath) {
       // I know it would be better to use a switch statement here
       // but the way that EJS handles switch statements keeps producing
       // errors.
       let blockType = blocks[blockPath]["type"];%>
<%_     if ( blockType == "For" ) { %>
<%_         let r = Math.random().toString(36).substring(7);
%>for( int <%-r%> = 0; <%-r%> < <%-blocks[blockPath]["attributes"]["times"]%>; <%-r%>++ ) {<%
     } else if ( blockType == "While" ) { %>
While
<%_     } else if ( blockType == "If/Else" || blockType == "If" ) { %>
if( <%-blocks[blocks[blockPath]["connections"]["Condition"]]["type"]%>() ) {
<%_     } else if ( blockType == "Hazard" ) { %>
Hazard();
<%_     } else if ( blockType == "Horn" ) { %>
Horn();
<%_     } else if ( blockType == "Left_Signal" ) { %>
LeftSignal();
<%_     } else if ( blockType == "Right_Signal" ) { 
%>RightSignal();<%
        } else if ( blockType == "Left" ) { %>
Left();
<%_     } else if ( blockType == "Right" ) { %>
Right();
<%_     } else if ( blockType == "Straight" ) { %>
Straight();
<%_     } else if ( blockType == "Safe_Left" ) { %>
SafeLeft();
<%_     } else if ( blockType == "Safe_Right" ) { %>
SafeRight();
<%_     } else if ( blockType == "Safe_Straight" ) { %>
SafeStraight();
<%_     } %>
<%_ } %>