/* Generated file based on ejs templates */
define([], function() {
    return {
    "carsim.ejs": "<%\nvar velocity = 2;\nvar duration = 3;\nvar angVel = 2*Math.PI;\n%>\n#!/usr/bin/env python\n#\n# Author: Jonathan Sprinkle\n# Copyright (c) 2015 Arizona Board of Regents\n# All rights reserved.\n#\n# Permission is hereby granted, without written agreement and without\n# license or royalty fees, to use, copy, modify, and distribute this\n# software and its documentation for any purpose, provided that the\n# above copyright notice and the following two paragraphs appear in\n# all copies of this software.\n#\n# IN NO EVENT SHALL THE ARIZONA BOARD OF REGENTS BE LIABLE TO ANY PARTY\n# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n# IF THE ARIZONA BOARD OF REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# THE ARIZONA BOARD OF REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER\n# IS ON AN \"AS IS\" BASIS, AND THE ARIZONA BOARD OF REGENTS HAS NO OBLIGATION\n# TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\n# This node generates cmd_vel inputs to the vehicle in order to make it move\n# around. Use the arrow keys to make the vehicle turn its wheels, move forward,\n# or backward. If you want to move forward (but turn left), first press the left\n# arrow key, then press up.\n\nimport rospy\nimport json\nimport time\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import String, Float64\nimport sys, getopt, math\n\nclass carsim:\n    #initializes car sim object with a publisher for movement and a subscriber for sensing\n    def __init__(self,ns):\n        self.ns = ns\n        rospy.init_node('carsim', anonymous=True)\n        self.pub_cmd_vel = rospy.Publisher('{0}/cmd_vel'.format(ns), Twist, queue_size=1)\n        self.sub_front_cam = rospy.Subscriber('/catvehicle/front_laser_points', LaserScan, self.callback)\n        #Initializes default velocity to 2 m/s and wheels are straight\n        self.x = <%-velocity%>\n        self.z = 0\n        self.seconds=<%-duration%>\n        #Array of degrees from scanner 180 total 1 per degree value is dist of object\n        self.ranges = []\n\n    #gets information from sensor and holds onto how far and what angle obstacle is\n    def callback(self,msg):\n        self.ranges = msg.ranges\n\n    #publishes movement to car for 3 seconds\n    def publish(self):\n        msg = Twist()\n        msg.linear.x = self.x\n        msg.angular.z = self.z\n        #Execution time per command\n        time_end = time.time()+self.seconds\n        while time.time()<time_end:\n            #for kids testing dynamic environment\n            if donkeyKongSafe(self):\n                self.pub_cmd_vel.publish(msg)\n            else:\n                tempX = self.x\n                tempZ = self.z\n                #Gets time left for execution of command\n                time_restart = time_end-time.time()\n                while not donkeyKongSafe(self):\n                    self.x = 0\n                    self.pub_cmd_vel.publish(msg)\n                time_end = time_end+time_restart\n                self.x = tempX\n                self.z = tempZ\n\ndef usage():\n    print('dsmlCarSim -n catvehicle')\n\ndef donkeyKongSafe(node):\n    for ang in node.ranges:\n        if ang < 2:\n            return False\n    return True\n\n#definition of left turn and sends to car to do\ndef left(node):\n    node.z = <%-angVel%>\n    node.publish()\n#definition of right turn and sends to car to do\ndef right(node):\n    node.z = -1*<%-angVel%>\n    node.publish()\n#definition of straight and sends to car to do\ndef straight(node):\n    node.z = 0\n    node.publish()\n#TODO better model for safe right turns\ndef safeRight(node):\n    for right in range(15,65,1):\n        if node.ranges[right]<=6:\n            return False\n    return True\n#TODO better model for safe left turns\ndef safeLeft(node):\n    for left in range(65,115,1):\n        if node.ranges[left]<=6:\n            return False\n    return True\n#TODO better model for safe straight\ndef safeStraight(node):\n    for mid in range(115,165,1):\n        if node.ranges[mid]<=6:\n            return False\n    return True\n\n\n#TODO hazard signal\n#def hazard(node):\n\n#TODO honk horn\n#def horn(node):\n\n#TODO left signal\n#def leftSign(node):\n\n#TODO right signal\n#def rightSign(node):\n\n#Parses JSON file for path and recreates the path returns queue of commands to execute\ndef createPath(data):\n    types = []\n    nodes = []\n    names = []\n    index = 0\n    #Gets first command\n    for entry in data:\n        if len(data[entry][\"connections\"])==1 and \"Out\" in data[entry][\"connections\"]:\n            types.append(data[entry][\"type\"])\n            nodes.append(data[entry])\n            names.append(entry)\n            break\n    #Loop to set rest of connections after first\n    while len(types)<len(data):\n        #Find next node\n        next = None\n        for cons in data[names[index]][\"connections\"]:\n            if \"Out\" in cons:\n                next = data[names[index]][\"connections\"][\"Out\"]\n        #add next node to lists\n        types.append(data[next][\"type\"])\n        nodes.append(data[next])\n        names.append(next)\n        index = index+1\n    return types\n\n#Begins execution and drives car\ndef main():\n    ns='catvehicle'\n    #open file\n    with open('/home/sam/turtle_proj_ws/src/turtle_proj/scripts/turtlePath.dmsl4kidz') as json_file:\n        data = json.load(json_file)\n    #Gets proper connections\n    path = createPath(data)\n    #Crates carsim instance\n    node = carsim(ns)\n    #Use for debugging\n    rate = rospy.Rate(1)\n    #Loops through path to drive car\n    while not rospy.is_shutdown():\n        #Must have at least one idk y\n        rate.sleep()\n        rate.sleep()\n        #rate.sleep()\n        #rate.sleep()\n        #rate.sleep()\n        for i in path:\n            #depending on command does action\n            if i==\"Left\" and safeLeft(node):\n                left(node)\n            elif i == \"Right\" and safeRight(node):\n                right(node)\n            elif i ==\"Straight\" and safeStraight(node):\n                straight(node)\n            #Debugging\n            #rate.sleep()\n            #rate.sleep()\n            #rate.sleep()\n            #rate.sleep()\n        rospy.spin()\n\nif __name__ == '__main__':\n    try:\n        main()\n    except rospy.ROSInterruptException:\n        pass\n",
    "simplePath.path.ejs": "<%_\n// First we have to format the JSON object into a form that works for us. We need to create a couple\n// of structs to hold places and pointers. The general idea of this is that we need to organize this JSON\n// object into the correct ordering for the program to work. If we can do that then we can use stacks and\n// stuff to keep a \"stack frame\" when we need to unravel.\n\n// Find the root node\nlet rootPath = \"\"\nfor(let block in blocks) {\n    let blockPath = blocks[block][\"type\"]\n    let connections = blocks[block][\"connections\"]\n    if( !connections[\"In\"] ) {\n        rootPath = JSON.stringify(block)\n        rootPath = rootPath.substring(1, rootPath.length-1);\n    }\n}\nconsole.info(\"Found root node at: \" + rootPath);\n\n// Execute down the tree until all paths are exhausted\nlet done = false;\nlet programStack = [];\nlet currentPath = rootPath;\nlet limit = 0;\nlet unclosedBrackets = 0;\nwhile( !done && limit <= 500) {\n    limit += 1\n    // Get the type of the current block\n    let currBlockType = blocks[currentPath][\"type\"];\n    console.info(\"Current node \" + currentPath + \" is of type \" + currBlockType);\n\n    // Execute the current block\n    exportCommand(currentPath);\n\n    // Check if the current block is of a special type\n    if( currBlockType == \"For\" ) {\n        // If the block is a for push it to the program stack and then go down the code to execute route\n        console.info(\"Pushing for and falling into for block\");\n        programStack.push(currentPath);\n        currentPath = blocks[currentPath][\"connections\"][\"Code to Execute\"];\n        continue;\n    } else if ( currBlockType == \"If/Else\" ) {\n        // If the block is an if push it to the program stack and then go down the true path\n        console.info(\"Pushing if and falling into if/else true block\");\n        programStack.push(currentPath);\n        currentPath = blocks[currentPath][\"connections\"][\"Out if True\"];\n        continue;\n    } else if ( currBlockType == \"If\" ) {\n        // If the block is an if push it to the program stack and then go down the true path\n        console.info(\"Pushing if and falling into if true block\");\n        programStack.push(currentPath);\n        currentPath = blocks[currentPath][\"connections\"][\"Truthy Out\"];\n        continue;\n    }\n\n    // Check if the current child has no children. This is the case in only two situations:\n    // 1) the program has ended - This is only true if the stack is also empty\n    // 2) the current path is exhausted - This is true when the stack is ! empty\n    if( !blocks[currentPath][\"connections\"][\"Out\"] ){\n        // Try and pop from program stack\n        if( programStack.length != 0 ) {\n            console.info(\"Current block has no children but the stack is not empty... Popping\");\n            // POP and check the type of the pop\n            let popPath = programStack.pop();\n            let popBlockType = blocks[popPath][\"type\"];\n\n            if ( popBlockType == \"For\" ) {\n                // If the popped block is a for then we just start going down the \"out\" path\n                currentPath = blocks[popPath][\"connections\"][\"Out\"];\n                closeBrackets(popBlockType);\n                console.info(\"Popping back to the last For block at \" + currentPath);\n            } else if ( popBlockType == \"If/Else\" ) {\n                // TODO: Put an else\n                // If the popped block is an if then we just start going down the \"out if false\" path\n                currentPath = blocks[popPath][\"connections\"][\"Out if False\"]\n                closeBrackets(popBlockType);\n                console.info(\"Popping back to the last If/Else block at \" + currentPath);\n            }\n            else if ( popBlockType == \"If\" ) {\n                // TODO: Put an else\n                // If the popped block is an if then we just start going down the \"out if false\" path\n                currentPath = blocks[popPath][\"connections\"][\"After\"]\n                closeBrackets(popBlockType);\n                console.info(\"Popping back to the last If block at \" + currentPath);\n            }\n\n        }\n        else {\n            // If there is no child and no pop-able things then we are donezo\n            console.info(\"No more children and no more stuff to pop. Exiting\");\n            done = true;\n        }\n    } else {\n        // If the block does have children then the current path is just the child\n        currentPath = blocks[currentPath][\"connections\"][\"Out\"];\n        console.info(\"Traversing to block's child at \" + currentPath);\n    }\n}\n\ncloseUnclosedBrackets();\n   function closeBrackets(blockType) {\n       if( blockType == \"If/Else\") {\n            unclosedBrackets+=1 %>\n} else {\n<%_     } else if ( blockType == \"For\" || blockType == \"If\") { %>\n}\n<%_ }\n} %>\n<%_ function closeUnclosedBrackets() {\n    for(let i = 0; i < unclosedBrackets; i++) { %>\n}\n<%_ }\n} %>\n<%_ function exportCommand(blockPath) {\n       // I know it would be better to use a switch statement here\n       // but the way that EJS handles switch statements keeps producing\n       // errors.\n       let blockType = blocks[blockPath][\"type\"];%>\n<%_     if ( blockType == \"For\" ) { %>\n<%_         let r = Math.random().toString(36).substring(7);\n%>for( int <%-r%> = 0; <%-r%> < <%-blocks[blockPath][\"attributes\"][\"times\"]%>; <%-r%>++ ) {<%\n     } else if ( blockType == \"While\" ) { %>\nWhile\n<%_     } else if ( blockType == \"If/Else\" || blockType == \"If\" ) { %>\nif( <%-blocks[blocks[blockPath][\"connections\"][\"Condition\"]][\"type\"]%>() ) {\n<%_     } else if ( blockType == \"Hazard\" ) { %>\nHazard();\n<%_     } else if ( blockType == \"Horn\" ) { %>\nHorn();\n<%_     } else if ( blockType == \"Left_Signal\" ) { %>\nLeftSignal();\n<%_     } else if ( blockType == \"Right_Signal\" ) { \n%>RightSignal();<%\n        } else if ( blockType == \"Left\" ) { %>\nLeft();\n<%_     } else if ( blockType == \"Right\" ) { %>\nRight();\n<%_     } else if ( blockType == \"Straight\" ) { %>\nStraight();\n<%_     } else if ( blockType == \"Safe_Left\" ) { %>\nSafeLeft();\n<%_     } else if ( blockType == \"Safe_Right\" ) { %>\nSafeRight();\n<%_     } else if ( blockType == \"Safe_Straight\" ) { %>\nSafeStraight();\n<%_     } %>\n<%_ } %>"
}});