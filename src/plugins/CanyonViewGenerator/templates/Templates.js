/* Generated file based on ejs templates */
define([], function() {
    return {
    "simplePath.path.ejs": "<%_\n// First we have to format the JSON object into a form that works for us. We need to create a couple\n// of structs to hold places and pointers. The general idea of this is that we need to organize this JSON\n// object into the correct ordering for the program to work. If we can do that then we can use stacks and\n// stuff to keep a \"stack frame\" when we need to unravel.\n\n// Find the root node\nlet rootPath = \"\"\nfor(let block in blocks) {\n    let blockPath = blocks[block][\"type\"]\n    let connections = blocks[block][\"connections\"]\n    if( !connections[\"In\"] ) {\n        rootPath = JSON.stringify(block)\n        rootPath = rootPath.substring(1, rootPath.length-1);\n    }\n}\nconsole.info(\"Found root node at: \" + rootPath);\n\n// Execute down the tree until all paths are exhausted\nlet done = false;\nlet programStack = [];\nlet currentPath = rootPath;\nlet limit = 0;\nlet unclosedBrackets = 0;\nwhile( !done && limit <= 500) {\n    limit += 1\n    // Get the type of the current block\n    let currBlockType = blocks[currentPath][\"type\"];\n    console.info(\"Current node \" + currentPath + \" is of type \" + currBlockType);\n\n    // Execute the current block\n    exportCommand(currentPath);\n\n    // Check if the current block is of a special type\n    if( currBlockType == \"For\" ) {\n        // If the block is a for push it to the program stack and then go down the code to execute route\n        console.info(\"Pushing for and falling into for block\");\n        programStack.push(currentPath);\n        currentPath = blocks[currentPath][\"connections\"][\"Code to Execute\"];\n        continue;\n    } else if ( currBlockType == \"If/Else\" ) {\n        // If the block is an if push it to the program stack and then go down the true path\n        console.info(\"Pushing if and falling into if/else true block\");\n        programStack.push(currentPath);\n        currentPath = blocks[currentPath][\"connections\"][\"Out if True\"];\n        continue;\n    } else if ( currBlockType == \"If\" ) {\n        // If the block is an if push it to the program stack and then go down the true path\n        console.info(\"Pushing if and falling into if true block\");\n        programStack.push(currentPath);\n        currentPath = blocks[currentPath][\"connections\"][\"Truthy Out\"];\n        continue;\n    }\n\n    // Check if the current child has no children. This is the case in only two situations:\n    // 1) the program has ended - This is only true if the stack is also empty\n    // 2) the current path is exhausted - This is true when the stack is ! empty\n    if( !blocks[currentPath][\"connections\"][\"Out\"] ){\n        // Try and pop from program stack\n        if( programStack.length != 0 ) {\n            console.info(\"Current block has no children but the stack is not empty... Popping\");\n            // POP and check the type of the pop\n            let popPath = programStack.pop();\n            let popBlockType = blocks[popPath][\"type\"];\n\n            if ( popBlockType == \"For\" ) {\n                // If the popped block is a for then we just start going down the \"out\" path\n                currentPath = blocks[popPath][\"connections\"][\"Out\"];\n                closeBrackets(popBlockType);\n                console.info(\"Popping back to the last For block at \" + currentPath);\n            } else if ( popBlockType == \"If/Else\" ) {\n                // TODO: Put an else\n                // If the popped block is an if then we just start going down the \"out if false\" path\n                currentPath = blocks[popPath][\"connections\"][\"Out if False\"]\n                closeBrackets(popBlockType);\n                console.info(\"Popping back to the last If/Else block at \" + currentPath);\n            }\n            else if ( popBlockType == \"If\" ) {\n                // TODO: Put an else\n                // If the popped block is an if then we just start going down the \"out if false\" path\n                currentPath = blocks[popPath][\"connections\"][\"After\"]\n                closeBrackets(popBlockType);\n                console.info(\"Popping back to the last If block at \" + currentPath);\n            }\n\n        }\n        else {\n            // If there is no child and no pop-able things then we are donezo\n            console.info(\"No more children and no more stuff to pop. Exiting\");\n            done = true;\n        }\n    } else {\n        // If the block does have children then the current path is just the child\n        currentPath = blocks[currentPath][\"connections\"][\"Out\"];\n        console.info(\"Traversing to block's child at \" + currentPath);\n    }\n}\n\ncloseUnclosedBrackets();\n   function closeBrackets(blockType) {\n       if( blockType == \"If/Else\") {\n            unclosedBrackets+=1 %>\n} else {\n<%_     } else if ( blockType == \"For\" || blockType == \"If\") { %>\n}\n<%_ }\n} %>\n<%_ function closeUnclosedBrackets() {\n    for(let i = 0; i < unclosedBrackets; i++) { %>\n}\n<%_ }\n} %>\n<%_ function exportCommand(blockPath) {\n       // I know it would be better to use a switch statement here\n       // but the way that EJS handles switch statements keeps producing\n       // errors.\n       let blockType = blocks[blockPath][\"type\"];%>\n<%_     if ( blockType == \"For\" ) { %>\n<%_         let r = Math.random().toString(36).substring(7);\n%>for( int <%-r%> = 0; <%-r%> < <%-blocks[blockPath][\"attributes\"][\"times\"]%>; <%-r%>++ ) {<%\n     } else if ( blockType == \"While\" ) { %>\nWhile\n<%_     } else if ( blockType == \"If/Else\" || blockType == \"If\" ) { %>\nif( <%-blocks[blocks[blockPath][\"connections\"][\"Condition\"]][\"type\"]%>() ) {\n<%_     } else if ( blockType == \"Hazard\" ) { %>\nHazard();\n<%_     } else if ( blockType == \"Horn\" ) { %>\nHorn();\n<%_     } else if ( blockType == \"Left_Signal\" ) { %>\nLeftSignal();\n<%_     } else if ( blockType == \"Right_Signal\" ) { \n%>RightSignal();<%\n        } else if ( blockType == \"Left\" ) { %>\nLeft();\n<%_     } else if ( blockType == \"Right\" ) { %>\nRight();\n<%_     } else if ( blockType == \"Straight\" ) { %>\nStraight();\n<%_     } else if ( blockType == \"Safe_Left\" ) { %>\nSafeLeft();\n<%_     } else if ( blockType == \"Safe_Right\" ) { %>\nSafeRight();\n<%_     } else if ( blockType == \"Safe_Straight\" ) { %>\nSafeStraight();\n<%_     } %>\n<%_ } %>"
}});