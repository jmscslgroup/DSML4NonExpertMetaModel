<%
var velocity = 2;
var duration = 3;
var angVel = Math.PI/(duration*2);
%>
#!/usr/bin/env python
#
# Author: Jonathan Sprinkle
# Copyright (c) 2015 Arizona Board of Regents
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in
# all copies of this software.
#
# IN NO EVENT SHALL THE ARIZONA BOARD OF REGENTS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
# IF THE ARIZONA BOARD OF REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE ARIZONA BOARD OF REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER
# IS ON AN "AS IS" BASIS, AND THE ARIZONA BOARD OF REGENTS HAS NO OBLIGATION
# TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

# This node generates cmd_vel inputs to the vehicle in order to make it move
# around. Use the arrow keys to make the vehicle turn its wheels, move forward,
# or backward. If you want to move forward (but turn left), first press the left
# arrow key, then press up.

import rospy
import json
import time
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from std_msgs.msg import String, Float64
import sys, getopt, math

class carsim:
    #initializes car sim object with a publisher for movement and a subscriber for sensing
    def __init__(self,ns):
        self.ns = ns
        rospy.init_node('carsim', anonymous=True)
        self.pub_cmd_vel = rospy.Publisher('{0}/cmd_vel'.format(ns), Twist, queue_size=1)
        self.sub_front_cam = rospy.Subscriber('/catvehicle/front_laser_points', LaserScan, self.callback)
        #Initializes default velocity to 2 m/s and wheels are straight
        self.x = <%=velocity%>
        self.z = 0
        self.seconds=<%=duration%>
        #Array of degrees from scanner 180 total 1 per degree value is dist of object
        self.ranges = []

    #gets information from sensor and holds onto how far and what angle obstacle is
    def callback(self,msg):
        self.ranges = msg.ranges

    #publishes movement to car for 3 seconds
    def publish(self):
        msg = Twist()
        msg.linear.x = self.x
        msg.angular.z = self.z
        #Execution time per command
        time_end = time.time()+self.seconds
        while time.time()<time_end:
            #for kids testing dynamic environment
            if donkeyKongSafe(self):
                self.pub_cmd_vel.publish(msg)
            else:
                tempX = self.x
                tempZ = self.z
                #Gets time left for execution of command
                time_restart = time_end-time.time()
                while not donkeyKongSafe(self):
                    self.x = 0
                    self.pub_cmd_vel.publish(msg)
                time_end = time_end+time_restart
                self.x = tempX
                self.z = tempZ

def usage():
    print('dsmlCarSim -n catvehicle')

def donkeyKongSafe(node):
    for ang in node.ranges:
        if ang < 2:
            return False
    return True

#definition of left turn and sends to car to do
def left(node):
    node.z = <%=angVel%>
    node.publish()
#definition of right turn and sends to car to do
def right(node):
    node.z = -1*<%=angVel%>
    node.publish()
#definition of straight and sends to car to do
def straight(node):
    node.z = 0
    node.publish()
#TODO better model for safe right turns
def safeRight(node):
    for right in range(15,65,1):
        if node.ranges[right]<=6:
            return False
    return True
#TODO better model for safe left turns
def safeLeft(node):
    for left in range(65,115,1):
        if node.ranges[left]<=6:
            return False
    return True
#TODO better model for safe straight
def safeStraight(node):
    for mid in range(115,165,1):
        if node.ranges[mid]<=6:
            return False
    return True


#TODO hazard signal
#def hazard(node):

#TODO honk horn
#def horn(node):

#TODO left signal
#def leftSign(node):

#TODO right signal
#def rightSign(node):

#Parses JSON file for path and recreates the path returns queue of commands to execute
def createPath(data):
    types = []
    nodes = []
    names = []
    index = 0
    #Gets first command
    for entry in data:
        if len(data[entry]["connections"])==1 and "Out" in data[entry]["connections"]:
            types.append(data[entry]["type"])
            nodes.append(data[entry])
            names.append(entry)
            break
    #Loop to set rest of connections after first
    while len(types)<len(data):
        #Find next node
        next = None
        for cons in data[names[index]]["connections"]:
            if "Out" in cons:
                next = data[names[index]]["connections"]["Out"]
        #add next node to lists
        types.append(data[next]["type"])
        nodes.append(data[next])
        names.append(next)
        index = index+1
    return types

#Begins execution and drives car
def main():
    ns='catvehicle'
    #open file
    with open('motionModel.json') as json_file:
        data = json.load(json_file)
    #Gets proper connections
    path = createPath(data)
    #Crates carsim instance
    node = carsim(ns)
    #Use for debugging
    rate = rospy.Rate(1)
    #Loops through path to drive car
    while not rospy.is_shutdown():
        #Must have at least one idk y
        rate.sleep()
        rate.sleep()
        #rate.sleep()
        #rate.sleep()
        #rate.sleep()
        for i in path:
            #depending on command does action
            if i=="Left" and safeLeft(node):
                left(node)
            elif i == "Right" and safeRight(node):
                right(node)
            elif i =="Straight" and safeStraight(node):
                straight(node)
            #Debugging
            #rate.sleep()
            #rate.sleep()
            #rate.sleep()
            #rate.sleep()
        while 1:
            straight(node)
        rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
