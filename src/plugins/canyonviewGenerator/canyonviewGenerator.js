/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Sun Apr 23 2017 17:18:32 GMT-0700 (MST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'common/util/ejs',
    'common/util/xmljsonconverter',
    './meta',
    './templates/Templates',
    'q'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    ejs,
    Converter,
    MetaTypes,
    programJsTemplate,
    Q) {

    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of canyonviewGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin canyonviewGenerator.
     * @constructor
     */
    var canyonviewGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.pluginMetadata = pluginMetadata;

        this.LANGUAGES = [
            {
                name: 'C++',
                generated: 'c++.generated.cpp.ejs',
                batFile: 'c++.bat.ejs',
                static: 'c++.simulator.cpp.ejs',
				fileExtension: 'cpp',
				fileName: 'Path'
            },{
                name: 'Path',
                generated: 'path.generated.txt.ejs',
                static: 'path.simulator.txt.ejs',
                fileExtension: 'txt',
				fileName: 'Path'
      },/**{
                name: 'ev3p',
                generated: 'robot program.ev3p.ejs',
                static: 'robot program.simulator.ev3p.ejs',
                fileExtension: 'ev3p',
				fileName: 'robot program'
            }
            **/
        ];
        /**
	   this.LANGUAGESLEGO = [
			{
						 name: 'ev3p',
						 generated: 'robot program.ev3p.ejs',
						 static: 'robot program.simulator.ev3p.ejs',
						 fileExtension: '.ev3p',
						 fileName: 'robot program'
           },
							 name: '___CopyrightYear',
							 generated: '___CopyrightYear.ejs',
							 fileExtension: '',
							 fileName: '___CopyrightYear'
							 },{
							 name: '___ProjectTitle',
							 generated: '___ProjectTitle.ejs',
							 fileExtension: '',
							 fileName: '___ProjectTitle'
							 },{
							 name: 'Activity.x3a',
							 generated: 'Activity.x3a.ejs',
							 fileExtension: '.x3a',
							 fileName: 'Activity'
							 },{
							 name: 'ActivityAssets.laz',
							 generated: 'ActivityAssets.laz.ejs',
							 fileExtension: '.laz',
							 fileName: 'ActivityAssets'
							 },{
							 name: 'Project.lvprojx',
							 generated: 'Project.lvprojx.ejs',
							 fileExtension: '.lvprojx',
							 fileName: 'Project'
							 }
		];**/
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    canyonviewGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    canyonviewGenerator.prototype = Object.create(PluginBase.prototype);
    canyonviewGenerator.prototype.constructor = canyonviewGenerator;
    canyonviewGenerator.prototype.getControlData = async function(abstractControlBlock)
    {
      var self = this,
          deferred = new Q.defer(),
          controlData = {
              id: self.core.getPath(abstractControlBlock),
              name: self.core.getAttribute(abstractControlBlock, 'name'),
              isStart: false,
              CodeToExecute:[],
              //distance: self.core.getAttribute(PrimitiveMotionNode, 'Distance')
              Connections: [
                  // event: <string>
                  // targetId: <nodePathStr>
              ]
          },
          error,
          counter;

          //builds children nodes TODO start with one no connections then work from there
let curr;
let promise1;
let promise2;

  await new Promise(done=>{ self.core.loadChildren(abstractControlBlock, async function (err, children)
  {


    if (err) {
       // Something went wrong!
       // Handle the error and return.
       console.log("Error with children");
    }
    // We have an array of the children and can get information from them.
  //get non-connection nodes
  let nonConn = [];
  children.forEach(async (child)=>
  {
    if(!(self.core.isConnection(child)))
    {
      nonConn.push(child);
    }
  })
  //get starting child
  nonConn.forEach(async (child)=>
  {
    console.log(self.core.getAttribute(child,'name'));

      self.core.loadCollection(child, 'dst', function (err, connections) {
      if (err)
      {
        deferred.reject(new Error(err));
        return;
      }
      if(connections.length > 1)
      {
        self.logger.error('Multiple incoming connections: ' + connections.length);
        deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
        return;
      }
      else if(connections.length === 0)
      {
        //Curr loses value after for loop ends
          curr = child;
          console.log('Found the starting child: ' + self.core.getAttribute(child,'name'));
          controlData.CodeToExecute.push(self.core.getAttribute(child,'name'));
          promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Found Start!"), 1000)
  });
      }
      });
  })

  await promise1;
  console.log("Async worked? "+self.core.getAttribute(curr,'name'));

  //Loop through src of curr node to add next nodes
  let k;
  for(k=0;k<nonConn.length-1;k++)
  {
    console.log("Current node: "+self.core.getAttribute(curr,'name'));

    await new Promise(next=>{
      self.core.loadCollection(curr, 'src', function (err, connections)
    {
        if (err)
        {
            deferred.reject(new Error(err));
            return;
        }
        var i;
        counter = connections.length;
        if(connections.length > 1)
        {
          self.logger.error('Multiple outgoing connections: ' + connections.length);
          deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
          return;
        }
      // For each connection load the destination state.
        for (i = 0; i < connections.length; i += 1)
        {
        self.core.loadPointer(connections[i], 'dst', getNextChild(connections[i]));
        }
        if (connections.length === 0)
        {
          deferred.resolve(controlData);
        }
        next()
    })
  })
  }
console.log("This is list after: "+controlData.CodeToExecute);
done();
  });

});
function done()
{
  console.log("Finished parsing kids hopefully CodeToExecute is updated");
}




function getNextChild(connection)
{
  return function(err, dstNode) {
  if (err) {
  // Handle error
  console.log("Error loading dest");
  }
  // Here we have access to the dstNode.
  curr = dstNode;
  controlData.CodeToExecute.push(self.core.getAttribute(curr,'name'));
  console.log(controlData.CodeToExecute);
  console.log("Added to list: "+self.core.getAttribute(dstNode,'name'));

}
}


          function atDestinationControl(connection) {

              return function (err, dstControl) {
                  console.log('In atDestinationControl(connection), length = ' + controlData.Connections.length);
                  if (err) {
                      error = new Error(err);
                  } else {
                      if(controlData.Connections.length >= 1) {

                          self.logger.error('Multiple Incoming connections: ' + controlData.Connections.length);
                          deferred.reject(new Error('Multiple Incoming connections: ' + controlData.Connections.length));
                          return;
                      }
                      controlData.Connections.push({
  //											distance: self.core.getAttribute(connection, 'Distance'),
  //											velocity: self.core.getAttribute(connection, 'Velocity'),
                          targetId: self.core.getPath(dstControl),
                          targetName: self.core.getAttribute(dstControl, 'name'),
                      });
                  }

                  counter -= 1;
                  if (counter === 0) {
                      if (error) {
                          deferred.reject(error);
                      } else {
                          deferred.resolve(controlData);
                      }
                    }
                  }
                }
                if (self.isMetaTypeOf(abstractControlBlock, self.META.For) === true) {
                  console.log('FOR LOOP');
                  controlData.Type = 6;
                  controlData.Times = self.core.getAttribute(abstractControlBlock,'times');
              }
              else if(self.isMetaTypeOf(abstractControlBlock,self.META.While)===true)
              {
                console.log('While LOOP');
                var condition= self.core.getAttribute(abstractControlBlock,'condition');
                let condNum=-1;
                if(condition==="SafeLeft")
                {
                  condNum = 1;
                }
                else if(condition==="SafeStraight")
                {
                  condNum = 2;
                }
                else
                {
                  condNum = 3;
                }
                controlData.Condition = condNum;
                controlData.Type = 7;
              }
              else if(self.isMetaTypeOf(abstractControlBlock,self.META.If)===true)
              {
                console.log('If');
                var condition= self.core.getAttribute(abstractControlBlock,'condition');
                let condNum=-1;
                if(condition==="SafeLeft")
                {
                  condNum = 1;
                }
                else if(condition==="SafeStraight")
                {
                  condNum = 2;
                }
                else
                {
                  condNum = 3;
                }
                controlData.Condition = condNum;
                controlData.Type = 8;
              }
              // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
              self.core.loadCollection(abstractControlBlock, 'src', function (err, connections) {
                  if (err) {
                      deferred.reject(new Error(err));
                      return;
                  }
                  var i;
                  counter = connections.length;

                  if(connections.length > 1) {
                      self.logger.error('Multiple outgoing connections: ' + connections.length);
                      deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                      return;
                  }
                  // For each connection load the destination state.
                  for (i = 0; i < connections.length; i += 1) {
                      self.core.loadPointer(connections[i], 'dst', atDestinationControl(connections[i]));
                  }

                  // Make sure to resolve when there are no connections.
                  if (connections.length === 0) {
                      deferred.resolve(controlData);
                  }
              });
              self.core.loadCollection(abstractControlBlock, 'dst', function (err, connections) {
                  if (err) {
                      deferred.reject(new Error(err));
                      return;
                  }
                  if(connections.length > 1) {
                      self.logger.error('Multiple incoming connections: ' + connections.length);
                      deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                      return;
                  } else if(connections.length == 0) {
                      console.log('Found the starting control: ' + self.core.getPath(abstractControlBlock));
                      controlData.isStart = true;
                  }
              });

              return deferred.promise;
}
    canyonviewGenerator.prototype.getActionData= function(abstractActionBlock)
    {
      var self = this,
          deferred = new Q.defer(),
          actionData = {
              id: self.core.getPath(abstractActionBlock),
              name: self.core.getAttribute(abstractActionBlock, 'name'),
              isStart: false,
              Connections: [
                  // event: <string>
                  // targetId: <nodePathStr>
              ]
          },
          error,
          counter;
          function atDestinationAction(connection) {

              return function (err, dstAction) {
                  console.log('In atDestinationAction(connection), length = ' + actionData.Connections.length);
                  if (err) {
                      error = new Error(err);
                  } else {
                      if(actionData.Connections.length >= 1) {

                          self.logger.error('Multiple Incoming connections: ' + actionData.Connections.length);
                          deferred.reject(new Error('Multiple Incoming connections: ' + actionData.Connections.length));
                          return;
                      }
                      actionData.Connections.push({
  //											distance: self.core.getAttribute(connection, 'Distance'),
  //											velocity: self.core.getAttribute(connection, 'Velocity'),
                          targetId: self.core.getPath(dstAction),
                          targetName: self.core.getAttribute(dstAction, 'name'),
                      });
                  }

                  counter -= 1;
                  if (counter === 0) {
                      if (error) {
                          deferred.reject(error);
                      } else {
                          deferred.resolve(actionData);
                      }

                                }
                              }
                            }
                            if (self.isMetaTypeOf(abstractActionBlock, self.META.Horn) === true) {
                              console.log('Horn');
                              actionData.Type = 9;
                          }
                          else if(self.isMetaTypeOf(abstractActionBlock,self.META.Left_Signal)===true)
                          {
                              console.log('Left Signal');
                            actionData.Type = 10;
                          }
                          else if(self.isMetaTypeOf(abstractActionBlock,self.META.Right_Signal)===true)
                          {
                              console.log('Right Signal');
                            actionData.Type = 11;
                          }
                          else if(self.isMetaTypeOf(abstractActionBlock,self.META.Hazard)===true)
                          {
                              console.log('Hazard');
                            actionData.Type = 12;
                          }
                          self.core.loadCollection(abstractActionBlock, 'src', function (err, connections) {
                              if (err) {
                                  deferred.reject(new Error(err));
                                  return;
                              }
                              var i;
                              counter = connections.length;

                              if(connections.length > 1) {
                                  self.logger.error('Multiple outgoing connections: ' + connections.length);
                                  deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                                  return;
                              }
                              // For each connection load the destination state.
                              for (i = 0; i < connections.length; i += 1) {
                                  self.core.loadPointer(connections[i], 'dst', atDestinationAction(connections[i]));
                              }

                              // Make sure to resolve when there are no connections.
                              if (connections.length === 0) {
                                  deferred.resolve(actionData);
                              }
                          });
                          self.core.loadCollection(abstractActionBlock, 'dst', function (err, connections) {
                              if (err) {
                                  deferred.reject(new Error(err));
                                  return;
                              }
                              if(connections.length > 1) {
                                  self.logger.error('Multiple incoming connections: ' + connections.length);
                                  deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                                  return;
                              } else if(connections.length == 0) {
                                  console.log('Found the starting motion: ' + self.core.getPath(abstractActionBlock));
                                  actionData.isStart = true;
                              }
                          });

                          return deferred.promise;
    }
    canyonviewGenerator.prototype.getMotionData = function(PrimitiveMotionNode) {
        var self = this,
            deferred = new Q.defer(),
            motionData = {
                id: self.core.getPath(PrimitiveMotionNode),
                name: self.core.getAttribute(PrimitiveMotionNode, 'name'),
                isStart: false,
                //distance: self.core.getAttribute(PrimitiveMotionNode, 'Distance'),
                velocity: self.core.getAttribute(PrimitiveMotionNode, 'Velocity'),
                Connections: [
                    // event: <string>
                    // targetId: <nodePathStr>
                ]
            },
            error,
            counter;
        function atDestinationMotion(connection) {

            return function (err, dstMotion) {
                console.log('In atDestinationMotion(connection), length = ' + motionData.Connections.length);
                if (err) {
                    error = new Error(err);
                } else {
                    if(motionData.Connections.length >= 1) {

                        self.logger.error('Multiple Incoming connections: ' + motionData.Connections.length);
                        deferred.reject(new Error('Multiple Incoming connections: ' + motionData.Connections.length));
                        return;
                    }

                    motionData.Connections.push({
//											distance: self.core.getAttribute(connection, 'Distance'),
//											velocity: self.core.getAttribute(connection, 'Velocity'),
                        targetId: self.core.getPath(dstMotion),
                        targetName: self.core.getAttribute(dstMotion, 'name'),
                    });
                }

                counter -= 1;
                if (counter === 0) {
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve(motionData);
                    }
                }
            }
        }

        if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.Straight) === true) {
            console.log('STRAIGHT!!!!');
            motionData.Type = 1;
            motionData.RadOfCurvature = 0;
            motionData.Distance = self.core.getAttribute(PrimitiveMotionNode, 'Distance');
            motionData.FinalTurnAngle = 0;
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.Left) === true) {
          console.log("Left");
            motionData.Type = 2;
            motionData.RadOfCurvature = self.core.getAttribute(PrimitiveMotionNode, 'RadOfCurvature');
            motionData.Distance = 0;
            motionData.FinalTurnAngle = self.core.getAttribute(PrimitiveMotionNode, 'FinalTurnAngle');
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.Right) === true) {
          console.log("Right");
            motionData.Type = 3;
            motionData.RadOfCurvature = self.core.getAttribute(PrimitiveMotionNode, 'RadOfCurvature');
            motionData.Distance = 0;
            motionData.FinalTurnAngle = self.core.getAttribute(PrimitiveMotionNode, 'FinalTurnAngle');
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.ZigZagLeft) === true) {
          console.log("ZigZagLeft");
            motionData.Type = 4;
            motionData.RadOfCurvature = 0;
            motionData.Distance = 0;
            motionData.FinalTurnAngle = 0;
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.ZigZagRight) === true) {
          console.log("ZigZagRight");
            motionData.Type = 5;
            motionData.RadOfCurvature = 0;
            motionData.Distance = 0;
            motionData.FinalTurnAngle = 0;
        }

        // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
        self.core.loadCollection(PrimitiveMotionNode, 'src', function (err, connections) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var i;
            counter = connections.length;

            if(connections.length > 1) {
                self.logger.error('Multiple outgoing connections: ' + connections.length);
                deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                return;
            }

            // For each connection load the destination state.
            for (i = 0; i < connections.length; i += 1) {
                self.core.loadPointer(connections[i], 'dst', atDestinationMotion(connections[i]));
            }

            // Make sure to resolve when there are no connections.
            if (connections.length === 0) {
                deferred.resolve(motionData);
            }
        });

        // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
        self.core.loadCollection(PrimitiveMotionNode, 'dst', function (err, connections) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            if(connections.length > 1) {
                self.logger.error('Multiple incoming connections: ' + connections.length);
                deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                return;
            } else if(connections.length == 0) {
                console.log('Found the starting motion: ' + self.core.getPath(PrimitiveMotionNode));
                motionData.isStart = true;
            }
        });

        return deferred.promise;

    }
    canyonviewGenerator.prototype.extractDataModel = function (callback) {
        var self = this,
            deferred = new Q.defer(),
            dataModel = {
                pathModel: {
                    name: '',
                    //initialState: null,
                    //finalStates: [],
                    startX: self.core.getAttribute(self.activeNode, 'startX'),
                    startY: self.core.getAttribute(self.activeNode, 'startY'),
                    startDirection: self.core.getAttribute(self.activeNode, 'startDirection'),
                    endX: self.core.getAttribute(self.activeNode, 'endX'),
                    endY: self.core.getAttribute(self.activeNode, 'endY'),
                    endDirection: self.core.getAttribute(self.activeNode, 'endDirection'),
                    obstacleY: self.core.getAttribute(self.activeNode, 'obstacleY'),
                    obstacleX: self.core.getAttribute(self.activeNode, 'obstacleX'),
                    motion: [
                        //id: <nodePathStr>
                        //name: <string>
                        //events: []
                    ]
                }
            };

        self.logger.info('In extractDataModel()');
        dataModel.pathModel.name = self.core.getAttribute(self.activeNode, 'name');
        self.logger.info('- extractDataModel() : Path name = ' + dataModel.pathModel.name);

        self.core.loadChildren(self.activeNode, function (err, children) {
            console.log('self.core.loadChildren(pathNode, function (err, children) {}');
            if (err) {
                deferred.reject(new Error(err));
                return;
            }

            var primitivePromises = [],
                i,
                metaType;

            for (i = 0; i < children.length; i += 1) {
                //metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                //self.logger.info(' - metaType = ' + metaType);
                if (self.isMetaTypeOf(children[i], self.META.PrimitiveMotion) === true) {
                    self.logger.info(' - Found primitive motion!');
                    primitivePromises.push(self.getMotionData(children[i]));
                    metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                    self.logger.info(' - metaType = ' + metaType);
                }
                else if(self.isMetaTypeOf(children[i],self.META.PrimitiveControl)===true)
                {
                  self.logger.info(' - Found primitive control!');
                  primitivePromises.push(self.getControlData(children[i]));
                  metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                  self.logger.info(' - metaType = ' + metaType);
                }
                else if(self.isMetaTypeOf(children[i],self.META.PrimitiveAction)===true)
                {
                  self.logger.info(' - Found primitive action!');
                  primitivePromises.push(self.getActionData(children[i]));
                  metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                  self.logger.info(' - metaType = ' + metaType);
                }
            }

            Q.all(primitivePromises)
                .then(function (primitiveData) {
                    self.logger.info('Q.all(primitivePromises).then(function (primitiveData){}');
                    dataModel.pathModel.motion = primitiveData;
                    deferred.resolve(dataModel);
                })
                .catch(deferred.reject);

            //console.log('generateDataModel :dataModel: ' + JSON.stringify(dataModel, null, 4));
            return deferred.promise;

        });''

        return deferred.promise;

        // return this.core.loadSubTree(self.activeNode)
        //     .then(function (nodes) {
        //         self.logger.info('In loadSubTree().then()');
        //         return dataModel;
        //     })
        //     .nodeify(callback);
    }
/**
	canyonviewGenerator.prototype.addLanguageToFilesLego = function (filesToAdd, dataModel, languageInfo) {
	   //var 	genFileName = 'GeneratedCode/' + languageInfo.name + '/' + dataModel.pathModel.name + '.' + languageInfo.fileExtension;//,
	   var 	genFileName = languageInfo.fileName + languageInfo.fileExtension;//,
	   //batFileName = 'FSM-GeneratedCode/' + languageInfo.name + '/execute.bat';

	   //this.logger.info('addLanguageToFiles()');

	   this.logger.info('addLanguageToFilesLego(): ' + genFileName);
	   //   this.logger.debug(batFileName);

	   //this.logger.info('programJsTemplate[languageInfo.generated] = ' + programJsTemplate[languageInfo.generated]);
	   //this.logger.info('programJsTemplate[' + languageInfo.generated + '] = ' + programJsTemplate[languageInfo.generated]);
	   //this.logger.info(JSON.stringify(programJsTemplate, null, 2));
	   //this.logger.info(JSON.stringify(MetaTypes, null, 2));

	   filesToAdd[genFileName] = ejs.render(programJsTemplate[languageInfo.generated], dataModel);
	   // filesToAdd[batFileName] = ejs.render(TEMPLATES[languageInfo.batFile], dataModel);

	   //TODO Add the static files too.
	   this.logger.info('Generated lego files for', languageInfo.name);

    };
**/
    canyonviewGenerator.prototype.addLanguageToFiles = function (filesToAdd, dataModel, languageInfo) {
	   //var 	genFileName = 'GeneratedCode/' + languageInfo.name + '/' + dataModel.pathModel.name + '.' + languageInfo.fileExtension;//,
	   var 	genFileName = 'GeneratedCode/' + languageInfo.name + '/' + languageInfo.fileName + '.' + languageInfo.fileExtension;//,
        //batFileName = 'FSM-GeneratedCode/' + languageInfo.name + '/execute.bat';

        //this.logger.info('addLanguageToFiles()');

        this.logger.info('addLanguageToFiles(): ' + genFileName);
        //   this.logger.debug(batFileName);

        //this.logger.info('programJsTemplate[languageInfo.generated] = ' + programJsTemplate[languageInfo.generated]);
        //this.logger.info('programJsTemplate[' + languageInfo.generated + '] = ' + programJsTemplate[languageInfo.generated]);
        //this.logger.info(JSON.stringify(programJsTemplate, null, 2));
        //this.logger.info(JSON.stringify(MetaTypes, null, 2));

        filesToAdd[genFileName] = ejs.render(programJsTemplate[languageInfo.generated], dataModel);
        // filesToAdd[batFileName] = ejs.render(TEMPLATES[languageInfo.batFile], dataModel);

        //TODO Add the static files too.
        this.logger.info('Generated files for', languageInfo.name);

    };

	//canyonviewGenerator.prototype.generateArtifactLego = function (dataModel) {
	   //var self = this,
	   ///filesToAdd = {},
	   //deferred = new Q.defer(),
	   //jsonToXml = new Converter.JsonToXml(),
	   //artifact = self.blobClient.createArtifact('lego');

	   //self.logger.info('generateArtifact:' + JSON.stringify(dataModel, null, 2));

	   //filesToAdd['motionModel.json'] = JSON.stringify(dataModel, null, 2);
	   //filesToAdd['metadata.json'] = JSON.stringify({
		//											projectId: self.projectId,
		//											commitHash: self.commitHash,
		//											branchName: self.branchName,
		//											timeStamp: (new Date()).toISOString(),
		//											pluginVersion: self.getVersion()
		//											}, null, 2);
	   //self.addXmlMotionModel(filesToAdd, dataModel);	// TODO: add
/**
	   self.logger.info('generateArtifactLego(): ' + artifact.name);
	   self.LANGUAGESLEGO.forEach(function (languageInfo) {
							  self.logger.info('adding Language...');
							  self.addLanguageToFilesLego(filesToAdd, dataModel, languageInfo);	// TODO: add
							  });

	   artifact.addFiles(filesToAdd, function (err) {
						 self.logger.info('artifact.addFiles()...');
						 if (err) {
						 deferred.reject(new Error(err));
						 return;
						 }
						 self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
														  deferred.reject(new Error(err));
														  return;
                }

                self.result.addArtifact(hashes[1]);
														  self.logger.info('generateArtifactLego(): ' + hashes[1]);
                deferred.resolve(dataModel);
														  });
						 });

	   return deferred.promise;
    };
**/
    canyonviewGenerator.prototype.generateArtifact = function (dataModel) {
        var self = this,
            filesToAdd = {},
            deferred = new Q.defer(),
            jsonToXml = new Converter.JsonToXml(),
            artifact = self.blobClient.createArtifact('GeneratedFiles');

        //self.logger.info('generateArtifact:' + JSON.stringify(dataModel, null, 2));

        filesToAdd['motionModel.json'] = JSON.stringify(dataModel, null, 2);
        filesToAdd['metadata.json'] = JSON.stringify({
            projectId: self.projectId,
            commitHash: self.commitHash,
            branchName: self.branchName,
            timeStamp: (new Date()).toISOString(),
            pluginVersion: self.getVersion()
        }, null, 2);
        //self.addXmlMotionModel(filesToAdd, dataModel);	// TODO: add

        self.LANGUAGES.forEach(function (languageInfo) {
            self.logger.info('adding Language...');
            self.addLanguageToFiles(filesToAdd, dataModel, languageInfo);	// TODO: add
        });


        artifact.addFiles(filesToAdd, function (err) {
            self.logger.info('artifact.addFiles()...');
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }

                self.result.addArtifact(hashes[0]);
                deferred.resolve(dataModel);
            });
        });

        return deferred.promise;
    };

    canyonviewGenerator.prototype.numberToLetter = function (theNumber) {
        switch(theNumber) {
            case 0:
                return "A";
            case 1:
                return "B";
            case 2:
                return "C";
            case 3:
                return "D";
	    case 4:
		return "E";
        }
        return "unknown";
    };
    canyonviewGenerator.prototype.letterToNumber = function (theLetter) {
        switch(theLetter) {
            case "A":
                return 0;
            case "B":
                return 1;
            case "C":
                return 2;
            case "D":
                return 3;
	    case "E":
		return 4;
        }
        return -999;
    };

    canyonviewGenerator.prototype.modelCheck = function (dModel) {
        var self = this,
            motion = {},
            dataModel = dModel,
            pathModel = dModel.pathModel,
            haveMotion = false,
            deferred = new Q.defer(),
            i,
            gridSize = 4,
            minNumberOfMoves = 6,
            maxNumberOfMoves = 100,
            count = 1,
            currentX,
            currentY,
            expectedX,
            expectedY,
            currentDirection = pathModel.startDirection;
            deferred.resolve(dataModel);

            return deferred.promise;
          }
/**
        self.logger.info('In modelCheck()');
        // Convert the calues to what the class expects:
        currentX = self.letterToNumber(pathModel.startX);
        if(currentX < 0) {
            deferred.reject(new Error('Unknown startX = ' + pathModel.startX));
            return deferred.promise;
        }
        currentY = gridSize - pathModel.startY;
        expectedX = self.letterToNumber(pathModel.endX);
        if(currentX < 0) {
            deferred.reject(new Error('Unknown endX = ' + pathModel.endX));
            return deferred.promise;
        }
        expectedY = gridSize - pathModel.endY;

        for (i = 0; i < pathModel.motion.length; i += 1) {
            if(pathModel.motion[i].isStart) {
                motion = pathModel.motion[i];
                haveMotion = true;
                break;
            }
        }

        while(haveMotion) {
            //console.log('Have a motion: ' + JSON.stringify(motion, null, 4));
            //console.log(' - PrimitiveMotionConnections: ' + JSON.stringify(motion.PrimitiveMotionConnections, null, 4));
            var priorPosition = '(' + currentX + ',' + currentY + ') : ' + currentDirection
            switch(motion.Type) {
                case 1:	// Straight
                    //currentDirection = currentDirection;	// won't change
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            break;
                        case "W":
                            currentX -= 1;
                            break;
                        case "N":
                            currentY += 1;
                            break;
                        case "S":
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 2:	// Left
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY += 1;
                            currentDirection = "N";
                            break;
                        case "W":
                            currentX -= 1;
                            currentY -= 1;
                            currentDirection = "S";
                            break;
                        case "N":
                            currentX -= 1;
                            currentY += 1;
                            currentDirection = "W";
                            break;
                        case "S":
                            currentX += 1;
                            currentY -= 1;
                            currentDirection = "E";
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 3:	// Right
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY -= 1;
                            currentDirection = "S";
                            break;
                        case "W":
                            currentX -= 1;
                            currentY += 1;
                            currentDirection = "N";
                            break;
                        case "N":
                            currentX += 1;
                            currentY += 1;
                            currentDirection = "E";
                            break;
                        case "S":
                            currentX -= 1;
                            currentY -= 1;
                            currentDirection = "W";
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 4:	// ZigZagLeft
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY += 1;
                            break;
                        case "W":
                            currentX -= 1;
                            currentY -= 1;
                            break;
                        case "N":
                            currentX -= 1;
                            currentY += 1;
                            break;
                        case "S":
                            currentX += 1;
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 5:	// ZigZagRight
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY -= 1;
                            break;
                        case "W":
                            currentX -= 1;
                            currentY += 1;
                            break;
                        case "N":
                            currentX += 1;
                            currentY += 1;
                            break;
                        case "S":
                            currentX -= 1;
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                default:
                    deferred.reject(new Error('Unknown motion!'));
                    return deferred.promise;
            }

            console.log( priorPosition + ' [' + motion.Type + ']-> (' + currentX + ',' + currentY + ') : ' + currentDirection);

            if(currentX < 0) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far West!'));
                return deferred.promise;
            } else if(currentX > gridSize-1) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far East!'));
                return deferred.promise;
            }
            if(currentY < 0) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far South!'));
                return deferred.promise;
            } else if(currentY > gridSize-1) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far North!'));
                return deferred.promise;
            }
	console.log('currentX = ' + currentX + '  obstacleX: ' + self.letterToNumber(pathModel.obstacleX));
	console.log('currentY = ' + currentY + '  obstacleY: ' + (gridSize-pathModel.obstacleY));
		if( currentX == self.letterToNumber(pathModel.obstacleX) && currentY == (gridSize-pathModel.obstacleY)) {
                deferred.reject(new Error('Ran into an obstacle on motion #' + count ));
                return deferred.promise;

	}

            haveMotion = false;
            count += 1;
            if( motion.PrimitiveMotionConnections.length != 0) {
                console.log('There exists an outgoing connection');

                for (i = 0; i < pathModel.motion.length; i += 1) {
                    if(pathModel.motion[i].id === motion.PrimitiveMotionConnections[0].targetId) {
                        haveMotion = true;
                        motion = pathModel.motion[i];
                        break;
                    }
                }
            }
        }

	if( count-1 < minNumberOfMoves ) {
		deferred.reject(new Error('Not enough moves!  you more than ' + minNumberOfMoves + ' moves, you have ' + (count-1) + ' moves.'));
                return deferred.promise;

	}
	if( count-1 > maxNumberOfMoves ) {
		deferred.reject(new Error('Too many moves!  you less than ' + maxNumberOfMoves + ' moves, you have ' + (count-1) + ' moves.'));
                return deferred.promise;

	}


        if(expectedX != currentX ||
            expectedY != currentY ||
            pathModel.endDirection !== currentDirection) {
            var errorString = 'Expected end at: ' + self.numberToLetter(expectedX) + (gridSize - expectedY) + ' facing ' + pathModel.endDirection;
            errorString += ', Actually ended at: ' + self.numberToLetter(currentX) + (gridSize - currentY) + ' facing ' + currentDirection;
            errorString += ', The start is: ' + pathModel.startX + pathModel.startY + ' facing ' + pathModel.startDirection;

            console.log('Model check Failed');
            deferred.reject(new Error('The end was not reached from the start! ' + errorString));
            return deferred.promise;
        }

        deferred.resolve(dataModel);

        return deferred.promise;
    };
**/
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    canyonviewGenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            deferred = new Q.defer(),
            nodeObject;
        self.logger.info('In main()');
        //self.updateMETA(self.metaTypes);

        // Using the logger.
        //self.logger.debug('This is a debug message.');
        //self.logger.info('This is an info message.');
        //self.logger.warn('This is a warning message.');
        //self.logger.error('This is an error message.');

        // Using the coreAPI to make changes.

        console.log('self.core.getPath(self.activeNode) = ' + self.core.getPath(self.activeNode));
        if (self.core.getPath(self.activeNode) === '' ||
            self.core.getAttribute(self.getMetaType(self.activeNode), 'name') !== 'Path') {
            //self.createMessage(self.activeNode, 'Active node is not a "UMLStateMachine".', 'error');
            callback(new Error('Active node is not a "Path".'), self.result);
            console.log('Selected Meta name: ' + self.core.getAttribute(self.getMetaType(self.activeNode), 'name'));
            return;
        }
        console.log('Selected Meta name: ' + self.core.getAttribute(self.getMetaType(self.activeNode), 'name'));

        self.extractDataModel()
            .then(function (dataModel) {
                //self.logger.info(JSON.stringify(dataModel, null, 4));
                self.logger.info('generateDataModel().then(): dataModel: ' + JSON.stringify(dataModel, null, 4));

                return self.modelCheck(dataModel);
            })
            .then(function (dataModel) {
                self.logger.info('generating artifacts!');
                return self.generateArtifact(dataModel);
            })

	   		//.then(function (dataModel) {
			 	//self.logger.info('generating Lego artifacts!');
			 	//return self.generateArtifactLego(dataModel);
			 //})
            .then(function () {
                //  console.log('generateDataModel().then().then(): dataModel: ' + JSON.stringify(dataModel, null, 4));
                console.log('In success part');
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                callback(err, self.result);
            })
            .done();

//        self.core.setAttribute(nodeObject, 'name', 'My new obj');
//        self.core.setRegistry(nodeObject, 'position', {x: 70, y: 70});


        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
        // self.save('canyonviewGenerator updated model.')
        //     .then(function () {
        //         self.result.setSuccess(true);
        //         callback(null, self.result);
        //     })
        //     .catch(function (err) {
        //         // Result success is false at invocation.
        //         callback(err, self.result);
        //     });

    };

    return canyonviewGenerator;
});
