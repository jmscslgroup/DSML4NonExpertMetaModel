/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Sun Apr 23 2017 17:18:32 GMT-0700 (MST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'common/util/ejs',
    'common/util/xmljsonconverter',
    './meta',
    './templates/Templates',
    'q'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    ejs,
    Converter,
    MetaTypes,
    programJsTemplate,
    Q) {

    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of canyonviewGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin canyonviewGenerator.
     * @constructor
     */
    var canyonviewGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.pluginMetadata = pluginMetadata;

        this.LANGUAGES = [
            {
                name: 'C++',
                generated: 'c++.generated.cpp.ejs',
                batFile: 'c++.bat.ejs',
                static: 'c++.simulator.cpp.ejs',
				fileExtension: 'cpp',
				fileName: 'Path'
            },{
                name: 'Path',
                generated: 'path.generated.txt.ejs',
                static: 'path.simulator.txt.ejs',
                fileExtension: 'txt',
				fileName: 'Path'
            },{
                name: 'ev3p',
                generated: 'robot program.ev3p.ejs',
                static: 'robot program.simulator.ev3p.ejs',
                fileExtension: 'ev3p',
				fileName: 'robot program'
            }
        ];
	   this.LANGUAGESLEGO = [
			{
						 name: 'ev3p',
						 generated: 'robot program.ev3p.ejs',
						 static: 'robot program.simulator.ev3p.ejs',
						 fileExtension: '.ev3p',
						 fileName: 'robot program'
							 },{
							 name: '___CopyrightYear',
							 generated: '___CopyrightYear.ejs',
							 fileExtension: '',
							 fileName: '___CopyrightYear'
							 },{
							 name: '___ProjectTitle',
							 generated: '___ProjectTitle.ejs',
							 fileExtension: '',
							 fileName: '___ProjectTitle'
							 },{
							 name: 'Activity.x3a',
							 generated: 'Activity.x3a.ejs',
							 fileExtension: '.x3a',
							 fileName: 'Activity'
							 },{
							 name: 'ActivityAssets.laz',
							 generated: 'ActivityAssets.laz.ejs',
							 fileExtension: '.laz',
							 fileName: 'ActivityAssets'
							 },{
							 name: 'Project.lvprojx',
							 generated: 'Project.lvprojx.ejs',
							 fileExtension: '.lvprojx',
							 fileName: 'Project'
							 }
		];
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    canyonviewGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    canyonviewGenerator.prototype = Object.create(PluginBase.prototype);
    canyonviewGenerator.prototype.constructor = canyonviewGenerator;

    canyonviewGenerator.prototype.getMotionData = function(PrimitiveMotionNode) {
        var self = this,
            deferred = new Q.defer(),
            motionData = {
                id: self.core.getPath(PrimitiveMotionNode),
                name: self.core.getAttribute(PrimitiveMotionNode, 'name'),
                isStart: false,
                //distance: self.core.getAttribute(PrimitiveMotionNode, 'Distance'),
                velocity: self.core.getAttribute(PrimitiveMotionNode, 'Velocity'),
                PrimitiveMotionConnections: [
                    // event: <string>
                    // targetId: <nodePathStr>
                ]
            },
            error,
            counter;
        function atDestinationMotion(connection) {

            return function (err, dstMotion) {
                console.log('In atDestinationMotion(connection), length = ' + motionData.PrimitiveMotionConnections.length);
                if (err) {
                    error = new Error(err);
                } else {
                    if(motionData.PrimitiveMotionConnections.length >= 1) {

                        self.logger.error('Multiple Incoming connections: ' + motionData.PrimitiveMotionConnections.length);
                        deferred.reject(new Error('Multiple Incoming connections: ' + motionData.PrimitiveMotionConnections.length));
                        return;
                    }

                    motionData.PrimitiveMotionConnections.push({
//											distance: self.core.getAttribute(connection, 'Distance'),
//											velocity: self.core.getAttribute(connection, 'Velocity'),
                        targetId: self.core.getPath(dstMotion),
                        targetName: self.core.getAttribute(dstMotion, 'name'),
                    });
                }

                counter -= 1;
                if (counter === 0) {
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve(motionData);
                    }
                }
            }
        }

        if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.Straight) === true) {
            console.log('STRAIGHT!!!!');
            motionData.Type = 1;
            motionData.RadOfCurvature = 0;
            motionData.Distance = self.core.getAttribute(PrimitiveMotionNode, 'Distance');
            motionData.FinalTurnAngle = 0;
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.Left) === true) {
            motionData.Type = 2;
            motionData.RadOfCurvature = self.core.getAttribute(PrimitiveMotionNode, 'RadOfCurvature');
            motionData.Distance = 0;
            motionData.FinalTurnAngle = self.core.getAttribute(PrimitiveMotionNode, 'FinalTurnAngle');
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.Right) === true) {
            motionData.Type = 3;
            motionData.RadOfCurvature = self.core.getAttribute(PrimitiveMotionNode, 'RadOfCurvature');
            motionData.Distance = 0;
            motionData.FinalTurnAngle = self.core.getAttribute(PrimitiveMotionNode, 'FinalTurnAngle');
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.ZigZagLeft) === true) {
            motionData.Type = 4;
            motionData.RadOfCurvature = 0;
            motionData.Distance = 0;
            motionData.FinalTurnAngle = 0;
        } else if (self.isMetaTypeOf(PrimitiveMotionNode, self.META.ZigZagRight) === true) {
            motionData.Type = 5;
            motionData.RadOfCurvature = 0;
            motionData.Distance = 0;
            motionData.FinalTurnAngle = 0;
        }

        // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
        self.core.loadCollection(PrimitiveMotionNode, 'src', function (err, connections) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var i;
            counter = connections.length;

            if(connections.length > 1) {
                self.logger.error('Multiple outgoing connections: ' + connections.length);
                deferred.reject(new Error('Multiple outgoing connections: ' + connections.length));
                return;
            }

            // For each connection load the destination state.
            for (i = 0; i < connections.length; i += 1) {
                self.core.loadPointer(connections[i], 'dst', atDestinationMotion(connections[i]));
            }

            // Make sure to resolve when there are no connections.
            if (connections.length === 0) {
                deferred.resolve(motionData);
            }
        });

        // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
        self.core.loadCollection(PrimitiveMotionNode, 'dst', function (err, connections) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            if(connections.length > 1) {
                self.logger.error('Multiple incoming connections: ' + connections.length);
                deferred.reject(new Error('Multiple incoming connections: ' + connections.length));
                return;
            } else if(connections.length == 0) {
                console.log('Found the starting motion: ' + self.core.getPath(PrimitiveMotionNode));
                motionData.isStart = true;
            }
        });

        return deferred.promise;

    }
    canyonviewGenerator.prototype.extractDataModel = function (callback) {
        var self = this,
            deferred = new Q.defer(),
            dataModel = {
                pathModel: {
                    name: '',
                    //initialState: null,
                    //finalStates: [],
                    startX: self.core.getAttribute(self.activeNode, 'startX'),
                    startY: self.core.getAttribute(self.activeNode, 'startY'),
                    startDirection: self.core.getAttribute(self.activeNode, 'startDirection'),
                    endX: self.core.getAttribute(self.activeNode, 'endX'),
                    endY: self.core.getAttribute(self.activeNode, 'endY'),
                    endDirection: self.core.getAttribute(self.activeNode, 'endDirection'),
                    obstacleY: self.core.getAttribute(self.activeNode, 'obstacleY'),
                    obstacleX: self.core.getAttribute(self.activeNode, 'obstacleX'),
                    motion: [
                        //id: <nodePathStr>
                        //name: <string>
                        //events: []
                    ]
                }
            };

        self.logger.info('In extractDataModel()');
        dataModel.pathModel.name = self.core.getAttribute(self.activeNode, 'name');
        self.logger.info('- extractDataModel() : Path name = ' + dataModel.pathModel.name);

        self.core.loadChildren(self.activeNode, function (err, children) {
            console.log('self.core.loadChildren(pathNode, function (err, children) {}');
            if (err) {
                deferred.reject(new Error(err));
                return;
            }

            var primitivePromises = [],
                i,
                metaType;

            for (i = 0; i < children.length; i += 1) {
                //metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                //self.logger.info(' - metaType = ' + metaType);
                if (self.isMetaTypeOf(children[i], self.META.PrimitiveMotion) === true) {
                    self.logger.info(' - Found primitive motion!');
                    primitivePromises.push(self.getMotionData(children[i]));
                    metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

                    self.logger.info(' - metaType = ' + metaType);
                }
            }

            Q.all(primitivePromises)
                .then(function (primitiveData) {
                    self.logger.info('Q.all(primitivePromises).then(function (primitiveData){}');
                    dataModel.pathModel.motion = primitiveData;
                    deferred.resolve(dataModel);
                })
                .catch(deferred.reject);

            //console.log('generateDataModel :dataModel: ' + JSON.stringify(dataModel, null, 4));
            return deferred.promise;

        });''

        return deferred.promise;

        // return this.core.loadSubTree(self.activeNode)
        //     .then(function (nodes) {
        //         self.logger.info('In loadSubTree().then()');
        //         return dataModel;
        //     })
        //     .nodeify(callback);
    }

	canyonviewGenerator.prototype.addLanguageToFilesLego = function (filesToAdd, dataModel, languageInfo) {
	   //var 	genFileName = 'GeneratedCode/' + languageInfo.name + '/' + dataModel.pathModel.name + '.' + languageInfo.fileExtension;//,
	   var 	genFileName = languageInfo.fileName + languageInfo.fileExtension;//,
	   //batFileName = 'FSM-GeneratedCode/' + languageInfo.name + '/execute.bat';

	   //this.logger.info('addLanguageToFiles()');

	   this.logger.info('addLanguageToFilesLego(): ' + genFileName);
	   //   this.logger.debug(batFileName);

	   //this.logger.info('programJsTemplate[languageInfo.generated] = ' + programJsTemplate[languageInfo.generated]);
	   //this.logger.info('programJsTemplate[' + languageInfo.generated + '] = ' + programJsTemplate[languageInfo.generated]);
	   //this.logger.info(JSON.stringify(programJsTemplate, null, 2));
	   //this.logger.info(JSON.stringify(MetaTypes, null, 2));

	   filesToAdd[genFileName] = ejs.render(programJsTemplate[languageInfo.generated], dataModel);
	   // filesToAdd[batFileName] = ejs.render(TEMPLATES[languageInfo.batFile], dataModel);

	   //TODO Add the static files too.
	   this.logger.info('Generated lego files for', languageInfo.name);

    };

    canyonviewGenerator.prototype.addLanguageToFiles = function (filesToAdd, dataModel, languageInfo) {
	   //var 	genFileName = 'GeneratedCode/' + languageInfo.name + '/' + dataModel.pathModel.name + '.' + languageInfo.fileExtension;//,
	   var 	genFileName = 'GeneratedCode/' + languageInfo.name + '/' + languageInfo.fileName + '.' + languageInfo.fileExtension;//,
        //batFileName = 'FSM-GeneratedCode/' + languageInfo.name + '/execute.bat';

        //this.logger.info('addLanguageToFiles()');

        this.logger.info('addLanguageToFiles(): ' + genFileName);
        //   this.logger.debug(batFileName);

        //this.logger.info('programJsTemplate[languageInfo.generated] = ' + programJsTemplate[languageInfo.generated]);
        //this.logger.info('programJsTemplate[' + languageInfo.generated + '] = ' + programJsTemplate[languageInfo.generated]);
        //this.logger.info(JSON.stringify(programJsTemplate, null, 2));
        //this.logger.info(JSON.stringify(MetaTypes, null, 2));

        filesToAdd[genFileName] = ejs.render(programJsTemplate[languageInfo.generated], dataModel);
        // filesToAdd[batFileName] = ejs.render(TEMPLATES[languageInfo.batFile], dataModel);

        //TODO Add the static files too.
        this.logger.info('Generated files for', languageInfo.name);

    };

	canyonviewGenerator.prototype.generateArtifactLego = function (dataModel) {
	   var self = this,
	   filesToAdd = {},
	   deferred = new Q.defer(),
	   jsonToXml = new Converter.JsonToXml(),
	   artifact = self.blobClient.createArtifact('lego');

	   //self.logger.info('generateArtifact:' + JSON.stringify(dataModel, null, 2));

	   //filesToAdd['motionModel.json'] = JSON.stringify(dataModel, null, 2);
	   //filesToAdd['metadata.json'] = JSON.stringify({
		//											projectId: self.projectId,
		//											commitHash: self.commitHash,
		//											branchName: self.branchName,
		//											timeStamp: (new Date()).toISOString(),
		//											pluginVersion: self.getVersion()
		//											}, null, 2);
	   //self.addXmlMotionModel(filesToAdd, dataModel);	// TODO: add

	   self.logger.info('generateArtifactLego(): ' + artifact.name);
	   self.LANGUAGESLEGO.forEach(function (languageInfo) {
							  self.logger.info('adding Language...');
							  self.addLanguageToFilesLego(filesToAdd, dataModel, languageInfo);	// TODO: add
							  });


	   artifact.addFiles(filesToAdd, function (err) {
						 self.logger.info('artifact.addFiles()...');
						 if (err) {
						 deferred.reject(new Error(err));
						 return;
						 }
						 self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
														  deferred.reject(new Error(err));
														  return;
                }

                self.result.addArtifact(hashes[1]);
														  self.logger.info('generateArtifactLego(): ' + hashes[1]);
                deferred.resolve(dataModel);
														  });
						 });

	   return deferred.promise;
    };

    canyonviewGenerator.prototype.generateArtifact = function (dataModel) {
        var self = this,
            filesToAdd = {},
            deferred = new Q.defer(),
            jsonToXml = new Converter.JsonToXml(),
            artifact = self.blobClient.createArtifact('GeneratedFiles');

        //self.logger.info('generateArtifact:' + JSON.stringify(dataModel, null, 2));

        filesToAdd['motionModel.json'] = JSON.stringify(dataModel, null, 2);
        filesToAdd['metadata.json'] = JSON.stringify({
            projectId: self.projectId,
            commitHash: self.commitHash,
            branchName: self.branchName,
            timeStamp: (new Date()).toISOString(),
            pluginVersion: self.getVersion()
        }, null, 2);
        //self.addXmlMotionModel(filesToAdd, dataModel);	// TODO: add

        self.LANGUAGES.forEach(function (languageInfo) {
            self.logger.info('adding Language...');
            self.addLanguageToFiles(filesToAdd, dataModel, languageInfo);	// TODO: add
        });


        artifact.addFiles(filesToAdd, function (err) {
            self.logger.info('artifact.addFiles()...');
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }

                self.result.addArtifact(hashes[0]);
                deferred.resolve(dataModel);
            });
        });

        return deferred.promise;
    };

    canyonviewGenerator.prototype.numberToLetter = function (theNumber) {
        switch(theNumber) {
            case 0:
                return "A";
            case 1:
                return "B";
            case 2:
                return "C";
            case 3:
                return "D";
	    case 4:
		return "E";
        }
        return "unknown";
    };
    canyonviewGenerator.prototype.letterToNumber = function (theLetter) {
        switch(theLetter) {
            case "A":
                return 0;
            case "B":
                return 1;
            case "C":
                return 2;
            case "D":
                return 3;
	    case "E":
		return 4;
        }
        return -999;
    };

    canyonviewGenerator.prototype.modelCheck = function (dModel) {
        var self = this,
            motion = {},
            dataModel = dModel,
            pathModel = dModel.pathModel,
            haveMotion = false,
            deferred = new Q.defer(),
            i,
            gridSize = 4,
            minNumberOfMoves = 6,
            maxNumberOfMoves = 100,
            count = 1,
            currentX,
            currentY,
            expectedX,
            expectedY,
            currentDirection = pathModel.startDirection;

        self.logger.info('In modelCheck()');
        // Convert the calues to what the class expects:
        currentX = self.letterToNumber(pathModel.startX);
        if(currentX < 0) {
            deferred.reject(new Error('Unknown startX = ' + pathModel.startX));
            return deferred.promise;
        }
        currentY = gridSize - pathModel.startY;
        expectedX = self.letterToNumber(pathModel.endX);
        if(currentX < 0) {
            deferred.reject(new Error('Unknown endX = ' + pathModel.endX));
            return deferred.promise;
        }
        expectedY = gridSize - pathModel.endY;

        for (i = 0; i < pathModel.motion.length; i += 1) {
            if(pathModel.motion[i].isStart) {
                motion = pathModel.motion[i];
                haveMotion = true;
                break;
            }
        }

        while(haveMotion) {
            //console.log('Have a motion: ' + JSON.stringify(motion, null, 4));
            //console.log(' - PrimitiveMotionConnections: ' + JSON.stringify(motion.PrimitiveMotionConnections, null, 4));
            var priorPosition = '(' + currentX + ',' + currentY + ') : ' + currentDirection
            switch(motion.Type) {
                case 1:	// Straight
                    //currentDirection = currentDirection;	// won't change
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            break;
                        case "W":
                            currentX -= 1;
                            break;
                        case "N":
                            currentY += 1;
                            break;
                        case "S":
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 2:	// Left
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY += 1;
                            currentDirection = "N";
                            break;
                        case "W":
                            currentX -= 1;
                            currentY -= 1;
                            currentDirection = "S";
                            break;
                        case "N":
                            currentX -= 1;
                            currentY += 1;
                            currentDirection = "W";
                            break;
                        case "S":
                            currentX += 1;
                            currentY -= 1;
                            currentDirection = "E";
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 3:	// Right
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY -= 1;
                            currentDirection = "S";
                            break;
                        case "W":
                            currentX -= 1;
                            currentY += 1;
                            currentDirection = "N";
                            break;
                        case "N":
                            currentX += 1;
                            currentY += 1;
                            currentDirection = "E";
                            break;
                        case "S":
                            currentX -= 1;
                            currentY -= 1;
                            currentDirection = "W";
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 4:	// ZigZagLeft
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY += 1;
                            break;
                        case "W":
                            currentX -= 1;
                            currentY -= 1;
                            break;
                        case "N":
                            currentX -= 1;
                            currentY += 1;
                            break;
                        case "S":
                            currentX += 1;
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                case 5:	// ZigZagRight
                    switch(currentDirection) {
                        case "E":
                            currentX += 1;
                            currentY -= 1;
                            break;
                        case "W":
                            currentX -= 1;
                            currentY += 1;
                            break;
                        case "N":
                            currentX += 1;
                            currentY += 1;
                            break;
                        case "S":
                            currentX -= 1;
                            currentY -= 1;
                            break;
                        default:
                            deferred.reject(new Error('Unknown direction!'));
                            return deferred.promise;
                    }
                    break;
                default:
                    deferred.reject(new Error('Unknown motion!'));
                    return deferred.promise;
            }

            console.log( priorPosition + ' [' + motion.Type + ']-> (' + currentX + ',' + currentY + ') : ' + currentDirection);

            if(currentX < 0) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far West!'));
                return deferred.promise;
            } else if(currentX > gridSize-1) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far East!'));
                return deferred.promise;
            }
            if(currentY < 0) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far South!'));
                return deferred.promise;
            } else if(currentY > gridSize-1) {
                deferred.reject(new Error('Out of bounds on motion #' + count + ', too far North!'));
                return deferred.promise;
            }
	console.log('currentX = ' + currentX + '  obstacleX: ' + self.letterToNumber(pathModel.obstacleX));
	console.log('currentY = ' + currentY + '  obstacleY: ' + (gridSize-pathModel.obstacleY));
		if( currentX == self.letterToNumber(pathModel.obstacleX) && currentY == (gridSize-pathModel.obstacleY)) {
                deferred.reject(new Error('Ran into an obstacle on motion #' + count ));
                return deferred.promise;
		
	}

            haveMotion = false;
            count += 1;
            if( motion.PrimitiveMotionConnections.length != 0) {
                console.log('There exists an outgoing connection');

                for (i = 0; i < pathModel.motion.length; i += 1) {
                    if(pathModel.motion[i].id === motion.PrimitiveMotionConnections[0].targetId) {
                        haveMotion = true;
                        motion = pathModel.motion[i];
                        break;
                    }
                }
            }
        }

	if( count-1 < minNumberOfMoves ) {
		deferred.reject(new Error('Not enough moves!  you more than ' + minNumberOfMoves + ' moves, you have ' + (count-1) + ' moves.'));
                return deferred.promise;

	}
	if( count-1 > maxNumberOfMoves ) {
		deferred.reject(new Error('Too many moves!  you less than ' + maxNumberOfMoves + ' moves, you have ' + (count-1) + ' moves.'));
                return deferred.promise;

	}


        if(expectedX != currentX ||
            expectedY != currentY ||
            pathModel.endDirection !== currentDirection) {
            var errorString = 'Expected end at: ' + self.numberToLetter(expectedX) + (gridSize - expectedY) + ' facing ' + pathModel.endDirection;
            errorString += ', Actually ended at: ' + self.numberToLetter(currentX) + (gridSize - currentY) + ' facing ' + currentDirection;
            errorString += ', The start is: ' + pathModel.startX + pathModel.startY + ' facing ' + pathModel.startDirection;

            console.log('Model check Failed');
            deferred.reject(new Error('The end was not reached from the start! ' + errorString));
            return deferred.promise;
        }

        deferred.resolve(dataModel);

        return deferred.promise;
    };


    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    canyonviewGenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            deferred = new Q.defer(),
            nodeObject;
        self.logger.info('In main()');
        //self.updateMETA(self.metaTypes);

        // Using the logger.
        //self.logger.debug('This is a debug message.');
        //self.logger.info('This is an info message.');
        //self.logger.warn('This is a warning message.');
        //self.logger.error('This is an error message.');

        // Using the coreAPI to make changes.

        console.log('self.core.getPath(self.activeNode) = ' + self.core.getPath(self.activeNode));
        if (self.core.getPath(self.activeNode) === '' ||
            self.core.getAttribute(self.getMetaType(self.activeNode), 'name') !== 'Path') {
            //self.createMessage(self.activeNode, 'Active node is not a "UMLStateMachine".', 'error');
            callback(new Error('Active node is not a "Path".'), self.result);
            console.log('Selected Meta name: ' + self.core.getAttribute(self.getMetaType(self.activeNode), 'name'));
            return;
        }
        console.log('Selected Meta name: ' + self.core.getAttribute(self.getMetaType(self.activeNode), 'name'));

        self.extractDataModel()
            .then(function (dataModel) {
                //self.logger.info(JSON.stringify(dataModel, null, 4));
                self.logger.info('generateDataModel().then(): dataModel: ' + JSON.stringify(dataModel, null, 4));

                return self.modelCheck(dataModel);
            })
            .then(function (dataModel) {
                self.logger.info('generating artifacts!');
                return self.generateArtifact(dataModel);
            })
	   		.then(function (dataModel) {
			 	self.logger.info('generating Lego artifacts!');
			 	return self.generateArtifactLego(dataModel);
			 })
            .then(function () {
                //  console.log('generateDataModel().then().then(): dataModel: ' + JSON.stringify(dataModel, null, 4));
                console.log('In success part');
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                callback(err, self.result);
            })
            .done();

//        self.core.setAttribute(nodeObject, 'name', 'My new obj');
//        self.core.setRegistry(nodeObject, 'position', {x: 70, y: 70});


        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
        // self.save('canyonviewGenerator updated model.')
        //     .then(function () {
        //         self.result.setSuccess(true);
        //         callback(null, self.result);
        //     })
        //     .catch(function (err) {
        //         // Result success is false at invocation.
        //         callback(err, self.result);
        //     });

    };

    return canyonviewGenerator;
});
